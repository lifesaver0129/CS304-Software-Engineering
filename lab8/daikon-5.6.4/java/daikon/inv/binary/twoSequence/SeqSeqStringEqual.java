  // #define PAIRWISECOMP_EQ PairwiseStringEqual
  // #define PAIRWISECOMP_LT PairwiseStringLessThan
  // #define PAIRWISECOMP_GT PairwiseStringGreaterThan
  // #define PAIRWISECOMP_LE PairwiseStringLessEqual
  // #define PAIRWISECOMP_GE PairwiseStringGreaterEqual

  // #define PAIRWISEINTEQUAL PairwiseStringEqual

// ***** This file is automatically generated from SeqComparison.java.jpp

package daikon.inv.binary.twoSequence;

import daikon.*;
import daikon.Quantify.QuantFlags;
import daikon.derive.binary.*;
import daikon.inv.*;
import daikon.suppress.*;
import java.util.*;
import java.util.logging.Logger;
import org.plumelib.util.ArraysPlume;
import org.plumelib.util.Intern;

/*>>>
import org.checkerframework.checker.interning.qual.*;
import org.checkerframework.checker.lock.qual.*;
import org.checkerframework.checker.nullness.qual.*;
import org.checkerframework.dataflow.qual.*;
import typequals.*;
*/

/**
 * Represents invariants between two sequences of String values. If order matters for each
 * variable (which it does by default), then the sequences are compared lexically. Prints as
 * {@code x[] == y[] lexically}.
 *

 * <p>If order doesn't matter for each variable, then the sequences are compared to see if they are
 * set equivalent. Prints as {@code x[] == y[]}.
 *

 * <p>If the auxiliary information (e.g., order matters) doesn't match between two variables, then
 * this invariant cannot apply to those variables.
 */
public class SeqSeqStringEqual extends TwoSequenceString

  implements EqualityComparison

{
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20030822L;

  // Variables starting with dkconfig_ should only be set via the
  // daikon.config.Configuration interface.
  /** Boolean. True iff SeqSeqStringEqual invariants should be considered. */
  public static boolean dkconfig_enabled = Invariant.invariantEnabledDefault;

  /** Debugging logger. */
  static final Logger debug = Logger.getLogger("daikon.inv.binary.twoSequence.SeqSeqStringEqual");

  @SuppressWarnings("interning")  // bug with generics
  static Comparator<String[]> comparator = new ArraysPlume.StringArrayComparatorLexical();

  boolean orderMatters;

  protected SeqSeqStringEqual(PptSlice ppt, boolean order) {
    super(ppt);
    orderMatters = order;
  }

  protected /*@Prototype*/ SeqSeqStringEqual(boolean order) {
    super();
    orderMatters = order;
  }

  private static /*@Prototype*/ SeqSeqStringEqual proto = new /*@Prototype*/ SeqSeqStringEqual(true);

  /** Returns the prototype invariant for SeqSeqStringEqual */
  public static /*@Prototype*/ SeqSeqStringEqual get_proto() {
    return proto;
  }

  /** Returns whether or not this invariant is enabled */
  @Override
  public boolean enabled() {
    return dkconfig_enabled;
  }

  /** Non-Equal SeqComparison is only valid on integral types */
  @Override
  public boolean instantiate_ok(VarInfo[] vis) {

    if (!valid_types(vis)) {
      return false;
    }

    VarInfo var1 = vis[0];
    VarInfo var2 = vis[1];
    ProglangType type1 = var1.type;
    ProglangType type2 = var2.type;

    return true;
  }

  /** Instantiates the invariant on the specified slice */
  @Override
  protected SeqSeqStringEqual instantiate_dyn(/*>>> @Prototype SeqSeqStringEqual this,*/ PptSlice slice) {
    boolean has_order = slice.var_infos[0].aux.hasOrder() && slice.var_infos[1].aux.hasOrder();
    return new SeqSeqStringEqual(slice, has_order);
  }

  @Override
  protected Invariant resurrect_done_swapped() {

    return this;
  }

  @Override
  public String repr(/*>>>@GuardSatisfied SeqSeqStringEqual this*/) {
    return "SeqSeqStringEqual" + varNames() + ": ,orderMatters=" + orderMatters
      + ",enoughSamples=" + enoughSamples()
      ;
  }

  /*@SideEffectFree*/
  @Override
  public String format_using(/*>>>@GuardSatisfied SeqSeqStringEqual this,*/ OutputFormat format) {
    // System.out.println("Calling SeqSeqStringEqual.format for: " + repr());

    if (format == OutputFormat.SIMPLIFY) {
      return format_simplify();
    }

    if (format == OutputFormat.DAIKON) {
      String name1 = var1().name_using(format);
      String name2 = var2().name_using(format);

      return name1 + " == " + name2;
    }

    if (format == OutputFormat.CSHARPCONTRACT) {
      String name1 = var1().csharp_collection_string();
      String name2 = var2().csharp_collection_string();

      String[] split1 = var1().csharp_array_split();
      String[] split2 = var2().csharp_array_split();
      // Pairwise equal.
      return "Contract.ForAll(0, " + split1[0] + ".Count(), i => " + split1[0] + "[i]" + split1[1] + ".Equals(" + split2[0] + "[i]" + split2[1] + "))";
    }

    if (format.isJavaFamily()) {
      String name1 = var1().name_using(format);
      String name2 = var2().name_using(format);

      return "daikon.Quant.pairwiseEqual(" + name1 + ", " + name2 + ")";
    }

    return format_unimplemented(format);
  }

  public String format_simplify(/*>>>@GuardSatisfied SeqSeqStringEqual this*/) {
    if (Invariant.dkconfig_simplify_define_predicates) {
      return format_simplify_defined();
    } else {
      return format_simplify_explicit();
    }
  }

  private String format_simplify_defined(/*>>>@GuardSatisfied SeqSeqStringEqual this*/) {
    String[] var1_name = var1().simplifyNameAndBounds();
    String[] var2_name = var2().simplifyNameAndBounds();
    if (var1_name == null || var2_name == null) {
      return String.format("%s.format_simplify_defined(%s): var1_name=%s, var2_name=%s, for %s",
                           getClass().getSimpleName(), this,
                           Arrays.toString(var1_name), Arrays.toString(var2_name), format());
    }
    return "(|lexical-==| "
      + var1_name[0] + " " + var1_name[1] + " " + var1_name[2] + " "
      + var2_name[0] + " " + var2_name[1] + " " + var2_name[2] + ")";
  }

  private String format_simplify_explicit(/*>>>@GuardSatisfied SeqSeqStringEqual this*/) {

      // A simple case: if two sequences are lexically equal iff they
      // are elementwise equal.
      String[] form = VarInfo.simplify_quantify(QuantFlags.element_wise(),
                                                 var1(), var2());
      return form[0]
        + "(EQ " + form[1] + " " + form[2] + ")" + form[3];

  }

  @Override
  public InvariantStatus check_modified(
      String /*@Interned*/ [] v1, String /*@Interned*/ [] v2, int count) {
    /// This does not do the right thing; I really want to avoid comparisons
    /// if one is missing, but not if one is zero-length.
    // // Don't make comparisons with empty arrays.
    // if ((v1.length == 0) || (v2.length == 0)) {
    //   return;
    // }

    int comparison = 0;
    if (orderMatters) {
      // Standard element wise comparison
       comparison = comparator.compare(v1, v2);
    } else {
      // Do a double subset comparison
      comparison = (ArraysPlume.isSubset(v1, v2) && ArraysPlume.isSubset( v2, v1)) ? 0 : -1;
    }

    if (!(comparison == 0) ) {
      return InvariantStatus.FALSIFIED;
    }
    return InvariantStatus.NO_CHANGE;
  }

  @Override
  public InvariantStatus add_modified(String /*@Interned*/ [] v1, String /*@Interned*/ [] v2, int count) {
    if (logDetail()) {
      log("add_modified (%s, %s)", Arrays.toString(v1), Arrays.toString(v2));
    }
        return check_modified(v1, v2, count);
  }

  @Override
  protected double computeConfidence() {

    // It's an equality invariant
    if (ppt.num_samples() == 0) {
      return Invariant.CONFIDENCE_UNJUSTIFIED;
    } else {
      return Invariant.CONFIDENCE_JUSTIFIED;
    }

  }

  // For Comparison interface
  @Override
  public double eq_confidence() {
      return getConfidence();
  }

  /*@Pure*/
  @Override
  public boolean isSameFormula(Invariant o) {
    return true;
  }

  /*@Pure*/
  @Override
  public boolean isExclusiveFormula(Invariant o) {
    return false;
  }

  /**
   * Since this invariant can be a postProcessed equality, we have to handle isObvious especially to
   * avoid circular isObvious relations.
   */
  /*@Pure*/
  @Override
  public /*@Nullable*/ DiscardInfo isObviousStatically_SomeInEquality() {
    if (var1().equalitySet == var2().equalitySet) {
      return isObviousStatically(this.ppt.var_infos);
    } else {
      return super.isObviousStatically_SomeInEquality();
    }
  }

  /**
   * Since this invariant can be a postProcessed equality, we have to handle isObvious especially to
   * avoid circular isObvious relations.
   */
  /*@Pure*/
  @Override
  public /*@Nullable*/ DiscardInfo isObviousDynamically_SomeInEquality() {
    if (logOn()) {
      log("Considering dynamically_someInEquality");
    }
    if (var1().equalitySet == var2().equalitySet) {
      return isObviousDynamically(this.ppt.var_infos);
    } else {
      return super.isObviousDynamically_SomeInEquality();
    }
  }

  /*@Pure*/
  @Override
  public /*@Nullable*/ DiscardInfo isObviousStatically(VarInfo[] vis) {

    return super.isObviousStatically(vis);
  }

  /*@Pure*/
  @Override
  public /*@Nullable*/ DiscardInfo isObviousDynamically(VarInfo[] vis) {
    DiscardInfo super_result = super.isObviousDynamically(vis);
    if (super_result != null) {
      return super_result;
    }
    assert ppt != null;

    return null;
  }

  @Override
  public void repCheck() {
    super.repCheck();
    /*
      This code is no longer needed now that the can_be_x's are gone
    if (!(this.can_be_eq || this.can_be_lt || this.can_be_gt)
        && ppt.num_samples() != 0) {
      System.err.println(this.repr());
      System.err.println(this.ppt.num_samples());
      throw new Error();
    }
    */
  }

  /*@Pure*/
  public boolean isEqual() {

    return true;
  }

  // Look up a previously instantiated invariant.
  public static /*@Nullable*/ SeqSeqStringEqual find(PptSlice ppt) {
    assert ppt.arity() == 2;
    for (Invariant inv : ppt.invs) {
      if (inv instanceof SeqSeqStringEqual) {
        return (SeqSeqStringEqual) inv;
      }
    }
    return null;
  }

  /** Returns a list of non-instantiating suppressions for this invariant. */
  /*@Pure*/
  @Override
  public /*@Nullable*/ NISuppressionSet get_ni_suppressions() {
    return suppressions;
  }

  /** Definition of this invariant (the suppressee) */
  private static NISuppressee suppressee = new NISuppressee(SeqSeqStringEqual.class, 2);

    private static /*@Nullable*/ NISuppressionSet suppressions = null;

}
