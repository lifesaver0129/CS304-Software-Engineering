<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.1, http://www.gnu.org/software/texinfo/ -->
<head><link rel="icon" href="../daikon-favicon.png" type="image/png"/>
<title>The Daikon Invariant Detector User Manual: Daikon output</title>

<meta name="description" content="The Daikon Invariant Detector User Manual: Daikon output">
<meta name="keywords" content="The Daikon Invariant Detector User Manual: Daikon output">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="General-Index.html#General-Index" rel="index" title="General Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="index.html#Top" rel="up" title="Top">
<link href="Enhancing-Daikon-output.html#Enhancing-Daikon-output" rel="next" title="Enhancing Daikon output">
<link href="Running-Daikon.html#Daikon-debugging-options" rel="previous" title="Daikon debugging options">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a name="Daikon-output"></a>
<div class="header">
<p>
Next: <a href="Enhancing-Daikon-output.html#Enhancing-Daikon-output" accesskey="n" rel="next">Enhancing Daikon output</a>, Previous: <a href="Running-Daikon.html#Running-Daikon" accesskey="p" rel="previous">Running Daikon</a>, Up: <a href="index.html#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Daikon-output-1"></a>
<h2 class="chapter">5 Daikon output</h2>

<p>Daikon outputs the invariants that it discovers in textual form to your
terminal.  This chapter describes how to interpret those invariants &mdash;
in other words, what do they mean?
</p>
<p>Daikon also creates a <samp>.inv</samp> file that contains the invariants in
serialized (binary) form.  You can use the <samp>.inv</samp> file to print the
invariants (see <a href="Tools.html#Printing-invariants">Printing invariants</a>) in a variety of formats, to
insert the invariants in your source code (see <a href="Tools.html#Annotate">Annotate</a>), to perform
run-time checking of the invariants (see <a href="Tools.html#Runtime_002dcheck-instrumenter">Runtime-check instrumenter</a>,
and <a href="Tools.html#InvariantChecker">InvariantChecker</a>), and to do various other operations.  See
<a href="Tools.html#Tools">Tools</a>, for descriptions of such tools.
</p>
<p>If you wish to write your own tools for processing invariants, you have
two general options.  You can parse Daikon&rsquo;s textual output, or you can
write Java code that processes the <samp>.inv</samp> file.  The <samp>.inv</samp>
file is simply a serialized
<a href="http://plse.cs.washington.edu/daikon/download/api/daikon/PptMap.html"><code>PptMap</code></a>
object.  In addition to reading the Javadoc, you can examine how the
other tools use this data structure.
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Invariant-syntax" accesskey="1">Invariant syntax</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Program-points" accesskey="2">Program points</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Variable-names" accesskey="3">Variable names</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Interpreting-output" accesskey="4">Interpreting output</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Invariant-list" accesskey="5">Invariant list</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Invariant-filters" accesskey="6">Invariant filters</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Invariant-syntax"></a>
<div class="header">
<p>
Next: <a href="#Program-points" accesskey="n" rel="next">Program points</a>, Up: <a href="#Daikon-output" accesskey="u" rel="up">Daikon output</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Invariant-syntax-1"></a>
<h3 class="section">5.1 Invariant syntax</h3>

<p>Daikon can produce output in a variety of formats.  Each of the format
names can be specified as an argument to the <samp>--format</samp> argument
of Daikon (see <a href="Running-Daikon.html#Options-to-control-Daikon-output">Options to control Daikon output</a>), <code>PrintInvariants</code>
(see <a href="Tools.html#Printing-invariants">Printing invariants</a>), and Annotate (see <a href="Tools.html#Annotate">Annotate</a>).
When passed on the command line, the format names are case-insensitive:
<samp>--format JML</samp> and <samp>--format jml</samp> have the same effect.
</p>
<p>You can enhance Daikon to produce output in other formats.  See
<a href="../developer/New-formatting-for-invariants.html#New-formatting-for-invariants">New formatting for invariants</a> in <cite>Daikon Developer Manual</cite>.
</p>
<a name="index-invariant-output-format"></a>
<a name="index-output-format_002c-for-invariants"></a>

<dl compact="compact">
<dd>
<a name="index-Daikon-output-format"></a>
<a name="index-output-format_002c-Daikon"></a>
</dd>
<dt>Daikon format</dt>
<dd>
<p>Daikon&rsquo;s default format is a mix of Java, mathematical logic, and some
additional extensions.  It is intended to concisely convey meaning to
programmers.
</p>
<a name="index-DBC-output-format"></a>
<a name="index-output-format_002c-DBC"></a>
<a name="index-Jtest-DBC-output-format"></a>
<a name="index-output-format_002c-Jtest-DBC"></a>
</dd>
<dt>DBC format</dt>
<dd><p>This format produces output in the design-by-contract (<em>DBC</em>) format
expected by Parasoft&rsquo;s <code>Jtest</code> tool (<a href="https://www.parasoft.com">https://www.parasoft.com</a>).
</p>

<a name="index-ESC_002fJava-output-format"></a>
<a name="index-output-format_002c-ESC_002fJava"></a>
</dd>
<dt>ESC/Java format</dt>
<dt>ESC format</dt>
<dd><p>The Extended Static Checker for Java (<code>ESC/Java</code>) is a programming tool
for finding errors in Java programs by checking annotations that are
inserted in source code; for more details, see
<a href="http://www.hpl.hp.com/downloads/crl/jtk/">http://www.hpl.hp.com/downloads/crl/jtk/</a>.  Daikon&rsquo;s <samp>ESC/Java</samp> format
(which can also be specified as <samp>ESC</samp> format) is intended for use with the
original <code>ESC/Java</code> tool.  Use Daikon&rsquo;s <samp>JML</samp> format for use with the
<a href="http://kindsoftware.com/products/opensource/ESCJava2/">ESC/Java2</a>
tool.
</p>
<a name="index-Java-output-format"></a>
<a name="index-output-format_002c-Java"></a>
</dd>
<dt>Java format</dt>
<dd><p>Write output as Java expressions.  This means that each invariant
is a valid Java expression, if inserted at the correct program
point: right after method entry, for method entry invariants;
right before method exit, for method exit invariants; or anywhere in
the code, for object invariants.
</p>
<p>There are two exceptions.  Method exit invariants that refer to
&lsquo;<samp>pre-state</samp>&rsquo;, such as &lsquo;<samp>x == old(x) + 1</samp>&rsquo;, are output with the tag
&lsquo;<samp>\old</samp>&rsquo; surrounding the &lsquo;<samp>pre-state</samp>&rsquo; expression (e.g. &lsquo;<samp>x ==
\old(x) + 1</samp>&rsquo;.  Method exit invariants that refer to the return value of
the method, such as &lsquo;<samp>return == x + y</samp>&rsquo;, are output with the tag
&lsquo;<samp>\result</samp>&rsquo; in place of the return value (e.g. &lsquo;<samp>\result == x + y</samp>&rsquo;).
These expression are obviously not valid Java code.
</p>

<a name="index-JML-output-format"></a>
<a name="index-output-format_002c-JML"></a>
</dd>
<dt>JML format</dt>
<dd><p>Produces output in JVM (Java Modeling Language,
<a href="http://www.jmlspecs.org">http://www.jmlspecs.org</a>); for details, see the
<a href="http://www.eecs.ucf.edu/~leavens/JML/documentation.shtml">JML Manual</a>.  <samp>JML</samp>
format lets you use the various JVM tools on Daikon invariants,
including runtime assertion checking and the
<a href="http://kindsoftware.com/products/opensource/ESCJava2/">ESC/Java2</a>
tool.
</p>

<a name="index-Simplify-output-format"></a>
<a name="index-output-format_002c-Simplify"></a>
</dd>
<dt>Simplify format</dt>
<dd><p>Produces output in the format expected by the Simplify automated theorem
prover; for details, see the
<a href="http://www.hpl.hp.com/downloads/crl/jtk/">Simplify distribution</a>.
</p>
<a name="index-CSharpContract-output-format"></a>
<a name="index-output-format_002c-CSharpContract"></a>
</dd>
<dt>CSharpContract format</dt>
<dd><p>Produces C# output for use with Microsoft&rsquo;s Code Contracts
<a href="http://www.microsoft.com/en-us/research/project/code-contracts/">http://www.microsoft.com/en-us/research/project/code-contracts/</a>.
The format employs some extension/utility methods to improve contract
readability; the library containing these methods can be found at
<a href="https://github.com/twschiller/daikon-code-contract-extensions">https://github.com/twschiller/daikon-code-contract-extensions</a>.
</p>
</dd>
</dl>


<hr>
<a name="Program-points"></a>
<div class="header">
<p>
Next: <a href="#Variable-names" accesskey="n" rel="next">Variable names</a>, Previous: <a href="#Invariant-syntax" accesskey="p" rel="previous">Invariant syntax</a>, Up: <a href="#Daikon-output" accesskey="u" rel="up">Daikon output</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Program-points-1"></a>
<h3 class="section">5.2 Program points</h3>
<a name="index-program-point"></a>

<p>A program point is a specific place in the source code, such as
immediately before a particular line of code.  Daikon&rsquo;s output is
organized by program points.
</p>
<a name="index-_003a_003a_003aENTER-program-point"></a>
<a name="index-ENTER-program-point"></a>
<a name="index-precondition"></a>

<p>For example, <code>foo():::ENTER</code> is the point at the entry to procedure
<code>foo()</code>; the invariants at that point are the preconditions for the
<code>foo()</code> method, properties that are always true when the procedure
is invoked.
</p>
<a name="index-_003a_003a_003aEXIT-program-point"></a>
<a name="index-EXIT-program-point"></a>
<a name="index-postcondition"></a>
<a name="index-hierarchy-of-program-points"></a>
<a name="index-program-point-hierarchy"></a>

<p>Likewise, <code>foo():::EXIT</code> is the program point at the procedure
exit, and invariants there are postconditions.  When there are multiple
exit points from a procedure (for instance, because of multiple
<code>return</code> statements), the different exits are differentiated by
suffixing them with their line numbers; for instance,
<code>StackAr.top():::EXIT79</code>.  The exit point lacking a line number (in
this example, <code>StackAr.top():::EXIT</code>) collects the postconditions
that are true at every numbered exit point.  This is an example of a
program point that represents a collection of locations in the program
source rather than a single location.  This concept is represented in
Daikon by the dataflow hierarchy, see
<a href="../developer/Dataflow-hierarchy.html#Dataflow-hierarchy">Dataflow hierarchy</a> in <cite>Daikon Developer Manual</cite>.
</p>
<p>The Java instrumenter Chicory selects names for program
points that include an indication of the argument and return types for
each method.  These signatures are presented in <code>Class.getName</code> format: one
character for each primitive type (&lsquo;<samp>B</samp>&rsquo; for byte, &lsquo;<samp>C</samp>&rsquo; for
character, &lsquo;<samp>Z</samp>&rsquo; for boolean, etc.);
&lsquo;<samp>L<var>classname</var>;</samp>&rsquo; for object types; and a &lsquo;<samp>[</samp>&rsquo;
prefix for each level of array nesting.
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#OBJECT-and-CLASS-program-points" accesskey="1">OBJECT and CLASS program points</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="OBJECT-and-CLASS-program-points"></a>
<div class="header">
<p>
Up: <a href="#Program-points" accesskey="u" rel="up">Program points</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="OBJECT-and-CLASS-program-points-1"></a>
<h4 class="subsection">5.2.1 OBJECT and CLASS program points</h4>
<a name="index-program-point-1"></a>

<a name="index-_003a_003a_003aOBJECT-program-point"></a>
<a name="index-OBJECT-program-point"></a>
<a name="index-_003a_003a_003aCLASS-program-point"></a>
<a name="index-CLASS-program-point"></a>
<a name="index-object-invariants"></a>
<a name="index-representation-invariants"></a>
<a name="index-class-invariants"></a>

<p>Two program point tags that have special meaning to Daikon&rsquo;s hierarchy
organization are <code>:::OBJECT</code> and <code>:::CLASS</code>.
The <code>:::OBJECT</code> tag indicates object invariants (sometimes called
representation invariants or class invariants) over all the instance
(member) fields and static fields of the class.  These properties always hold
for any object of the given class, from the point of view of a client or
user.  These properties hold at entry to and exit from every public
method of the class (except not the entry to constructors, when fields
are not yet initialized).
</p>
<p>The <code>:::CLASS</code> tag is just like <code>:::OBJECT</code>, but only for
static variables, which have only one value for all objects.  Static
fields and instance fields are often used for different purposes.
Daikon&rsquo;s separation of the two types of fields permits programmers to
see the properties over the static fields without knowing which are the
static fields and pick them out of the <code>:::OBJECT</code> program point.
</p>
<a name="index-private-methods"></a>

<p>(By contrast, <samp>ESC/Java</samp> and <samp>JML</samp> make class invariants hold even at the
entry and exit of private methods.  Their designers believe that most
private methods preserve the class invariant and are called only when
the class invariant holds.  <samp>ESC/Java</samp> and <samp>JML</samp> require an explicit
<em>helper</em> annotation to indicate a private method for which the class
invariant does not hold.)
</p>
<p>A trace file does not contain samples for the <code>:::OBJECT</code> and
<code>:::CLASS</code> program points.  Variable values for these artificial
program points are constructed from samples that do appear in a trace file.
For example, an object invariant is a property that holds at entry to and
exit from every public method of the class, so the <code>:::OBJECT</code> program
point is constructed from samples at those points.
</p>

<hr>
<a name="Variable-names"></a>
<div class="header">
<p>
Next: <a href="#Interpreting-output" accesskey="n" rel="next">Interpreting output</a>, Previous: <a href="#Program-points" accesskey="p" rel="previous">Program points</a>, Up: <a href="#Daikon-output" accesskey="u" rel="up">Daikon output</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Variable-names-1"></a>
<h3 class="section">5.3 Variable names</h3>

<p>A front end produces a trace file that associates trace variable names
with values.  Trace variable names need not be exactly the same as the
variables in the program.  The trace may contain values that are not
held in any program variables; in this case, the front end must make up
a name to express that value (see below for examples).
</p>
<p>Daikon ignores variable names when inferring invariants; it uses the
names only when performing output.  (Thus, the only practical
restriction on trace names is that the <code>VarInfoName parse</code> method
must be able to parse the name.)
</p>
<p>By convention, trace variables are similar to program variables and
field accesses.  For example, <code>w</code> and <code>x.y.z</code> are legal trace
variables.  (So are &lsquo;<samp>a[i]</samp>&rsquo;, and
&lsquo;<samp>a[0].next</samp>&rsquo;, but these are usually handled as derived variables
instead; see below.)  As in languages such as
Java and C, a period character represents field access and square
brackets represent selecting an element of a sequence.
</p>
<a name="index-derived-variables_002c-explanation-of"></a>

<p>In addition to variables that appear in the trace file, Daikon creates
additional variables, called <em>derived variables</em>, by combining trace
variables.  For example, for any array <code>a</code> and integer <code>i</code>,
Daikon creates a derived variable <code>a[i]</code>.  This is not a variable
in the program (and this expression might not even appear in the source
code), but it may still be useful to compute invariants over this
expression.  For a list of derived variables and how to control Daikon&rsquo;s
use of them, see <a href="Enhancing-Daikon-output.html#Options-to-enable_002fdisable-derived-variables">Options to enable/disable derived variables</a>.
</p>
<a name="index-nonsensical-values-for-variables"></a>

<p>Some trace variables and derived variables may represent meaningless
expressions; in such a circumstance, the value is said to be nonsensical
(see <a href="../developer/Nonsensical-values.html#Nonsensical-values">Nonsensical values</a> in <cite>Daikon Developer Manual</cite>).
</p>
<p>The remainder of this section describes conventions for naming
expressions.  Those that cannot be named by simple C/Java expressions
are primarily related to arrays and sequences.  (In part, these special
expressions are necessary because Daikon can only handle variables of
scalar (integer, floating-point, boolean, String) and array-of-scalar
types.  Daikon cannot handle structs, classes, or multidimensional
arrays or structures, but such data structures can be represented as
scalars and arrays by choosing variable names that indicate their
relationship.)
</p>

<ul>
<li> <code>a[i]</code> array access.
<code>a</code> and <code>i</code> are themselves
arbitrary variable names, of array and integral type, respectively.

</li><li> <a name="index-_002d1-array-index-_0028counts-from-end-of-array_0029"></a>
<a name="index-negative-array-index-_0028counts-from-end-of-array_0029"></a>
<code>a[-1]</code> from-end array access.
<code>a[-1]</code> denotes the last element of array <code>a</code>;
it is syntactic sugar for <code>a[a.length-1]</code>.

</li><li> <a name="index-_005b_005d-variable-name-_0028array-contents_0029"></a>
<code>a[]</code> array contents.
For array-valued expression <code>a</code>, all of its elements, as a
sequence.  Simply using the expression <code>a</code> means the identity
(address or hashcode) of the array, not a list of its elements.  For two
arrays <code>a</code> and <code>b</code>, &lsquo;<samp>a=b</samp>&rsquo; implies &lsquo;<samp>a[]=b[]</samp>&rsquo;, but
&lsquo;<samp>a[]=b[]</samp>&rsquo; does not imply &lsquo;<samp>a=b</samp>&rsquo;.

</li><li> <code>x.y</code>, <code>x-&gt;y</code> field access.
When field access is applied to a structure/class, it has the usual
meaning of selecting one field from the structure/class.

<p>When field access is applied to an array, it means to map the field
access across the elements of the array.  For example, if <code>a</code> is an
array, then <code>a[].foo</code> is the sequence consisting of the <code>foo</code>
fields of each of the elements of <code>a</code>.  Likewise,
<code>a[].foo.bar</code> contains the <code>bar</code> fields of <code>a[].foo</code>.  By
contrast, <code>a.foo</code> does not make sense, because one cannot ask for
the <code>foo</code> field of an address, and <code>a[].foo[]</code> would be a
two-dimensional array.
</p>
</li><li> <a name="index-_002egetClass_0028_0029-variable"></a>
As in Java, <code>x.getClass()</code> is the runtime type of <code>x</code>, which may
differ from its declared type.

</li><li> <a name="index-_002elength-variable-name"></a>
<code>a.length</code> is the length (number of elements) of array <code>a</code>;
this is not necessarily the number of initialized or used elements.

</li><li> <a name="index-_002etoString-variable"></a>
<code>s.toString</code> is the string value of String <code>s</code>, namely a
sequence of characters.

</li><li> <code>Classname.varname</code> static class variable.
Static variables of a class have names of the form
&lsquo;<samp><var>classname</var>.<var>varname</var></samp>&rsquo;

</li><li> <a name="index-orig_0028_0029-variable-_0028pre_002dstate-value_0029"></a>
<a name="index-pre_002dstate-variables"></a>
<code>orig(x)</code> refers to the value of variable <code>x</code> upon
entry to a procedure (because the procedure body might modify the value
of <code>x</code>).  These variables appear only at <code>:::EXIT</code> program
points.  Typically, <code>orig()</code> variables do not appear in the trace,
but are automatically created by Daikon when it matches up
<code>:::ENTER</code> and <code>:::EXIT<var>nn</var></code> program points.
See <a href="#orig-variable-example">orig variable example</a>.

<p>This variable prints as <code>orig</code> when using Daikon output format
(see <a href="#Invariant-syntax">Invariant syntax</a>), but may print differently in other formats
(such as <code>\old</code>).
</p>
</li><li> <a name="index-post_0028_0029-variable-_0028post_002dstate-value_0029"></a>
<a name="index-post_002dstate-variables"></a>
<code>post(x)</code> refers to the value of variable <code>x</code> upon exit from a
procedure.  Such a value is usually written simply <code>x</code>; the
<code>post</code> prefix is needed only within an <code>orig</code> expression, when
the post-state value needs to be referenced.  Just as <code>orig</code> may
be used only in a post-state context and specifies an expression to be
evaluated in the &lsquo;<samp>pre-state</samp>&rsquo;, <code>post</code> may be used only in a
&lsquo;<samp>pre-state</samp>&rsquo; context and specifies an expression to be evaluated in the
post-state.  See <a href="#orig-variable-example">orig variable example</a>.



</li><li> <a name="index-_002f-variable-_0028C-global-or-file_002dstatic_0029"></a>
<code>/globalVar</code> C global variable.  In C output, global variables with
external linkage are
prefixed with a slash.  For instance, global <code>/x</code> is distinct from
procedure parameter <code>/x</code>.  (In Java programs, variables can be
distinguished by prefixing them with <code>this.</code> or, for class-static
variables, a class name.)

</li><li> <code>myfile_c/staticVar</code> C static variable.  In C output, file-static
variables have names of the form &lsquo;<samp><var>filename</var>/<var>varname</var></samp>&rsquo;,
where periods (&lsquo;<samp>.</samp>&rsquo;) in the filename are converted into underscores
(&lsquo;<samp>_</samp>&rsquo;).  For example, &lsquo;<samp>Global_c/x</samp>&rsquo; is the name for a
file-static variable <code>x</code> declared in the file <samp>Global.c</samp>).

</li><li> <a name="index-_0040-variable-_0028C-function_002dscoped-static_0029"></a>
<code>myfile_c@funcname/funcStaticVar</code> C function-scoped static variable.
In C output, for static variables which are
declared within functions, an at-sign &lsquo;<samp>@</samp>&rsquo; separates the filename
and the function name and then a slash separates the function name and
variable name (e.g., &lsquo;<samp>Global_c@main/funcStaticVar</samp>&rsquo; for a static
variable <code>funcStaticVar</code> declared within the function <code>main</code>
in the file <samp>Global.c</samp>).

</li></ul>

<a name="index-local-variables"></a>
<a name="index-variables_002c-local"></a>
<a name="index-temporary-_0028local_0029-variables"></a>
<a name="index-variables_002c-temporary-_0028local_0029"></a>
<p>Daikon&rsquo;s current front ends do not produce output for local variables,
only for variables visible from outside a procedure.  (Also see the
<samp>--std-visibility</samp> option to Chicory, <a href="Front-ends-_0028instrumentation_0029.html#Chicory-options">Chicory options</a>.)
More generally, Daikon&rsquo;s front ends produce output at procedure exit and
entry, not within the procedure.  Thus,
Daikon&rsquo;s output forms a specification from the view of a client of a
procedure.  If you wish to compute invariants over local variables, you
can extend one of Daikon&rsquo;s front ends (or request us to do so).
An alternative that permits computing invariants at arbitrary locations
is to call a dummy procedure, passing all the variables of interest.
The dummy procedure&rsquo;s pre and postconditions will be identical and will
represent the invariants at the point of call.
</p>

<p>The array introduction operator <code>[]</code> can made Daikon variables look
slightly odd, but it is intended to assist in interpreting the variables
and to provide an indication that the variable name cannot be
substituted directly in a program as an expression.
</p>
<p>Each array introduction operator <code>[]</code> increases the dimensionality
of the variable, and each array indexing operation <code>[i]</code> decreases
it.  Since all Daikon variables are scalars or one-dimensional arrays,
these operators must be matched up, or have at most one more <code>[]</code>
than <code>[i]</code>.  (There is one exception:  according to a strict
interpretation of the rules, the C/Java expression <code>a[i]</code> would
turn into the Daikon variable <code>a[][i]</code>, since it does not change
the dimensionality of any expression it appears in.  However, that would
be even more confusing, and the point is to avoid confusion, so by
convention Daikon front ends use just <code>a[i]</code>, not <code>a[][i]</code>.
Strictly speaking, none of the <code>[]</code> operators is necessary, since a
user with a perfect knowledge of the type of each program variable and
field could use that to infer the type of any Daikon expression.)
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#orig-variable-example" accesskey="1">orig variable example</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="orig-variable-example"></a>
<div class="header">
<p>
Up: <a href="#Variable-names" accesskey="u" rel="up">Variable names</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="orig_0028_0029-variable-example"></a>
<h4 class="subsection">5.3.1 orig() variable example</h4>

<a name="index-orig_0028_0029-variable-_0028pre_002dstate-value_0029-1"></a>

<p>This section gives an example of use of <code>orig()</code> and <code>post()</code>
variables and arrays.
</p>
<p>Suppose you have initially that (in Java syntax)
</p><div class="example">
<pre class="example">int i = 0;
int[] a = new int[] { 22, 23 };
int[] b = new int[] { 46, 47 };
</pre></div>

<p>and then you run the following:
</p><div class="example">
<pre class="example">// pre-state values at this point
a[0] = 24;
a[1] = 25
a = b;
a[0] = 48;
a[1] = 49;
i = 1;
// post-state values at this point
</pre></div>

<p>The values of various variables are as follows:
</p>
<dl compact="compact">
<dt><code>orig(a[i]) = 22</code></dt>
<dd><p>The value of <code>a[i]</code> in the &lsquo;<samp>pre-state</samp>&rsquo;: {22, 23}[0]
</p>
</dd>
<dt><code>orig(a[])[orig(i)] = 22</code></dt>
<dd><p>This is the same as orig(a[i]):   {22, 23}[0].
</p>
</dd>
<dt><code>orig(a[])[i] = 23</code></dt>
<dd><p>The value of <code>a[]</code> in the &lsquo;<samp>pre-state</samp>&rsquo; (which is an array object, not
a reference), indexed by the post-state value of i:  {22, 23}[1]
</p>
</dd>
<dt><code>orig(a)[orig(i)] = 24</code></dt>
<dd><p><code>orig(a)</code> is the original value of the reference <code>a</code>, not
<code>a</code><tt>'s</tt> original elements: {24, 25}[0]
</p>
</dd>
<dt><code>orig(a)[i] = 25</code></dt>
<dd><p>The original pointer value of a, indexed by the post-state value
of i:  {24, 25}[1]
</p>
</dd>
<dt><code>a[orig(i)] = 48</code></dt>
<dd><p>In the post-state, <code>a</code> indexed by the original value of
<code>i</code>: {48, 49}[0]
</p>
</dd>
<dt><code>a[i] = 49</code></dt>
<dd><p>The value of <code>a[i]</code> in the post-state.
</p>
</dd>
<dt><code>b = orig(b) = <var>some hashcode</var></code></dt>
<dd><p>The identity of the array <code>b</code> has not changed.
</p>
</dd>
<dt><code>b[] = [48, 49]</code></dt>
<dt><code>orig(b[]) = [46, 47]</code></dt>
<dd><p>For an array <code>b</code>, &lsquo;<samp>b=orig(b)</samp>&rsquo; does not imply &lsquo;<samp>b[]=orig(b[])</samp>&rsquo;.
</p>
</dd>
<dt><code>orig(a[post(i)]) = 23</code></dt>
<dd><p>The &lsquo;<samp>pre-state</samp>&rsquo; value of <code>a[1]</code> (because the post-state value of
<code>i</code> is 1):  {22, 23}[1]
</p>
</dd>
</dl>

<hr>
<a name="Interpreting-output"></a>
<div class="header">
<p>
Next: <a href="#Invariant-list" accesskey="n" rel="next">Invariant list</a>, Previous: <a href="#Variable-names" accesskey="p" rel="previous">Variable names</a>, Up: <a href="#Daikon-output" accesskey="u" rel="up">Daikon output</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Interpreting-Daikon-output"></a>
<h3 class="section">5.4 Interpreting Daikon output</h3>

<a name="index-Exiting_002c-in-Daikon-output"></a>

<p>If nothing gets printed before the &lsquo;<samp>Exiting</samp>&rsquo; line, then Daikon
found no invariants.  You can get a little bit more information by using
the <samp>--output_num_samples</samp> flag to Daikon
(see <a href="Running-Daikon.html#Options-to-control-Daikon-output">Options to control Daikon output</a>).
</p>
<a name="index-nonsensical-values_002c-ignored-when-computing-invariants"></a>

<p>Daikon&rsquo;s output is predicated on the assumption that all expressions
that get evaluated are sensible.  For instance, if Daikon prints
&lsquo;<samp>a.b == 0</samp>&rsquo;, then that means that <em>if</em> &lsquo;<samp>a.b</samp>&rsquo; is sensible (that
is, &lsquo;<samp>a</samp>&rsquo; is non-null), then its value is zero.  When &lsquo;<samp>a</samp>&rsquo; is
&lsquo;<samp>null</samp>&rsquo;, then &lsquo;<samp>a.b</samp>&rsquo; is called <em>nonsensical</em>.  Daikon&rsquo;s output
ignores all nonsensical values.  If you would like
the assumptions to be printed explicitly, then set the
<samp>daikon.Daikon.guardNulls</samp> configuration option (see <a href="Enhancing-Daikon-output.html#General-configuration-options">General configuration options</a>).
</p>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Redundant-invariants" accesskey="1">Redundant invariants</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Equal-variables" accesskey="2">Equal variables</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Has-only-one-value-variables" accesskey="3">Has only one value variables</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Object-inequality" accesskey="4">Object inequality</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Redundant-invariants"></a>
<div class="header">
<p>
Next: <a href="#Equal-variables" accesskey="n" rel="next">Equal variables</a>, Up: <a href="#Interpreting-output" accesskey="u" rel="up">Interpreting output</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Redundant-invariants-1"></a>
<h4 class="subsection">5.4.1 Redundant invariants</h4>

<p>By default, Daikon does not display redundant invariants &mdash; those
that are implied by other invariants in the output &mdash; because such
results would merely clutter the output without adding any valuable
information.  For instance, if Daikon reports &lsquo;<samp>x==y</samp>&rsquo;, then it never
also reports &lsquo;<samp>x-1==y-1</samp>&rsquo;.  You can control this behavior to some extent by
disabling invariant filters; see <a href="#Invariant-filters">Invariant filters</a>.
(You can also print all invariants, even
redundant ones, by saving the invariants to a <samp>.inv</samp> file and
then using the <code>PrintInvariants</code> (see <a href="Tools.html#Printing-invariants">Printing invariants</a>) or Diff
(see <a href="Tools.html#Invariant-Diff">Invariant Diff</a>) programs to print the results.)
</p>

<hr>
<a name="Equal-variables"></a>
<div class="header">
<p>
Next: <a href="#Has-only-one-value-variables" accesskey="n" rel="next">Has only one value variables</a>, Previous: <a href="#Redundant-invariants" accesskey="p" rel="previous">Redundant invariants</a>, Up: <a href="#Interpreting-output" accesskey="u" rel="up">Interpreting output</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Equal-variables-1"></a>
<h4 class="subsection">5.4.2 Equal variables</h4>

<p>If two variables <code>x</code> and <code>y</code> are equal, then any invariant
about <code>x</code> is also true about <code>y</code>.  Daikon chooses one variable
(the leader) from the set of equal variables, and only prints invariants
over the leader.
</p>
<p>Suppose that <code>a = b = c</code>.  Then Daikon will print <code>a = b</code> and
<code>a = c</code>, but not <code>b = c</code>.  Furthermore, Daikon might print
<code>a &gt; d</code>, but would not print <code>b &gt; d</code> or <code>c &gt; d</code>.
</p>
<p>You can control which variables are in an equality set;
see <a href="../developer/Variable-comparability.html#Variable-comparability">Variable comparability</a> in <cite>Daikon Developer Manual</cite>.
</p>

<hr>
<a name="Has-only-one-value-variables"></a>
<div class="header">
<p>
Next: <a href="#Object-inequality" accesskey="n" rel="next">Object inequality</a>, Previous: <a href="#Equal-variables" accesskey="p" rel="previous">Equal variables</a>, Up: <a href="#Interpreting-output" accesskey="u" rel="up">Interpreting output</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Has-only-one-value-variables-1"></a>
<h4 class="subsection">5.4.3 Has only one value variables</h4>

<a name="index-has-only-one-value_002c-in-invariant-output"></a>
<a name="index-hashcode-type_002c-for-variables"></a>

<p>The output &lsquo;<samp><var>var</var> has only one value</samp>&rsquo; in Daikon&rsquo;s output means
that every time that variable <var>var</var> was encountered, it had the same
value.  Daikon ordinarily reports the actual value, as in
&lsquo;<samp><var>var</var> == 22</samp>&rsquo;.
Typically, the &ldquo;has only one value&rdquo; output means that the variable is a
hashcode or address &mdash; that is, its declared type is &lsquo;<samp>hashcode</samp>&rsquo;
(see <a href="../developer/Variable-declarations.html#Variable-declarations">Variable declarations</a> in <cite>Daikon Developer Manual</cite>).
For example, &lsquo;<samp><var>var</var> == 0x38E8A</samp>&rsquo; is not very illuminating,
but it is still interesting that
<var>var</var> was never rebound to a different object.
</p>
<p>Note that &lsquo;<samp><var>var</var> has only one value</samp>&rsquo; is different from
saying that <var>var</var> is unmodified.
</p>
<p>A variable might have only one value but <em>not</em> be reported as unmodified
because the variable is not a parameter to a procedure &mdash; for instance,
if a routine always returns the same object, or in a class invariant.  A
variable can be reported as unmodified but <em>not</em> have only one value
because the variable is never modified during any execution of the
procedure, but has different values on different invocations of the
procedure.
</p>

<hr>
<a name="Object-inequality"></a>
<div class="header">
<p>
Previous: <a href="#Has-only-one-value-variables" accesskey="p" rel="previous">Has only one value variables</a>, Up: <a href="#Interpreting-output" accesskey="u" rel="up">Interpreting output</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Object-inequality-1"></a>
<h4 class="subsection">5.4.4 Object inequality</h4>

<p>Daikon may report &lsquo;<samp>x &lt; y</samp>&rsquo; where the operator &lsquo;<samp>&lt;</samp>&rsquo; is not
applicable to the type of &lsquo;<samp>x</samp>&rsquo; and &lsquo;<samp>y</samp>&rsquo;, as in &lsquo;<samp>myString &lt;
otherString</samp>&rsquo;.
</p>
<p>In this case, the invariant means that the first expression is always less
than the second, according to the &lsquo;<samp>Comparable.compareTo</samp>&rsquo; method.
</p>


<hr>
<a name="Invariant-list"></a>
<div class="header">
<p>
Next: <a href="#Invariant-filters" accesskey="n" rel="next">Invariant filters</a>, Previous: <a href="#Interpreting-output" accesskey="p" rel="previous">Interpreting output</a>, Up: <a href="#Daikon-output" accesskey="u" rel="up">Daikon output</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Invariant-list-1"></a>
<h3 class="section">5.5 Invariant list</h3>

<a name="index-invariant-list"></a>
<a name="index-invariants_002c-list-of-all"></a>
<p>The following is a list of all of the invariants that Daikon detects.
Each invariant has a configuration enable switch.  By default most invariants
are enabled.  Any that are not enabled by default are indicated below.
Some invariants also have additional configuration switches that control
their behavior.  These are indicated below as well.
See <a href="Enhancing-Daikon-output.html#Options-to-enable_002fdisable-specific-invariants">Options to enable/disable specific invariants</a>.
</p>
<dl compact="compact">
<dt>AndJoiner</dt>
<dd><p>This is a special invariant used internally by Daikon to represent an antecedent invariant in an
implication where that antecedent consists of two invariants anded together.
</p>
</dd>
<dt>CommonFloatSequence</dt>
<dd><p>Represents sequences of double values that contain a common subset. Prints as
<code>{e1, e2, e3, ...} subset of x[]</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.sequence.CommonFloatSequence.enabled</samp>&rsquo;.
</p>
<p>See also the following configuration option:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.unary.sequence.CommonFloatSequence.hashcode_seqs</samp>&rsquo;
    </li></ul>

</dd>
<dt>CommonSequence</dt>
<dd><p>Represents sequences of long values that contain a common subset. Prints as
<code>{e1, e2, e3, ...} subset of x[]</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.sequence.CommonSequence.enabled</samp>&rsquo;.
</p>
<p>See also the following configuration option:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.unary.sequence.CommonSequence.hashcode_seqs</samp>&rsquo;
    </li></ul>

</dd>
<dt>CommonStringSequence</dt>
<dd><p>Represents string sequences that contain a common subset. Prints as <code>{s1, s2, s3, ...}
 subset of x[]</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.stringsequence.CommonStringSequence.enabled</samp>&rsquo;.
</p>
</dd>
<dt>CompleteOneOfScalar</dt>
<dd><p>Tracks every unique value and how many times it occurs. Prints as <code>x has values: v1 v2 v3
 ...</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.scalar.CompleteOneOfScalar.enabled</samp>&rsquo;.
</p>
</dd>
<dt>CompleteOneOfString</dt>
<dd><p>Tracks every unique value and how many times it occurs. Prints as either <code>x has no values</code>
or as <code>x has values: &quot;v1&quot; &quot;v2&quot; &quot;v3&quot; ...</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.string.CompleteOneOfString.enabled</samp>&rsquo;.
</p>
</dd>
<dt>DummyInvariant</dt>
<dd><p>This is a special invariant used internally by Daikon to represent invariants whose meaning
Daikon doesn&rsquo;t understand. The only operation that can be performed on a DummyInvariant is to
print it. In particular, the invariant cannot be tested against a sample: the invariant is always
assumed to hold and is always considered to be statistically justified.
</p>
<p>The main use for a dummy invariant is to represent a splitting condition that appears in a
<code>.spinfo</code> file. The <code>.spinfo</code> file can indicate an arbitrary Java expression, which
might not be equivalent to any invariant in Daikon&rsquo;s grammar.
</p>
<p>Ordinarily, Daikon uses splitting conditions to split data, then seeks to use that split data
to form conditional invariants out of its standard built-in invariants. If you wish the
expression in the .spinfo file to be printed as an invariant, whether or not it is itself
discovered by Daikon during invariant detection, then the configuration option <code>daikon.split.PptSplitter.dummy_invariant_level</code> must be set, and formatting information must be
supplied in the splitter info file.
</p>
</dd>
<dt>EltLowerBound</dt>
<dd><p>Represents the invariant that each element of a sequence of long values is greater than or
equal to a constant. Prints as <code>x[] elements &gt;= c</code>.
</p>
<p>See also the following configuration options:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.unary.sequence.EltLowerBound.minimal_interesting</samp>&rsquo;
    </li><li> &lsquo;<samp>daikon.inv.unary.sequence.EltLowerBound.maximal_interesting</samp>&rsquo;
    </li></ul>

</dd>
<dt>EltLowerBoundFloat</dt>
<dd><p>Represents the invariant that each element of a sequence of double values is greater than or
equal to a constant. Prints as <code>x[] elements &gt;= c</code>.
</p>
<p>See also the following configuration options:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.unary.sequence.EltLowerBoundFloat.minimal_interesting</samp>&rsquo;
    </li><li> &lsquo;<samp>daikon.inv.unary.sequence.EltLowerBoundFloat.maximal_interesting</samp>&rsquo;
    </li></ul>

</dd>
<dt>EltNonZero</dt>
<dd><p>Represents the invariant &quot;x != 0&quot; where x represents all of the elements of a sequence of
long. Prints as <code>x[] elements != 0</code>.
</p>
</dd>
<dt>EltNonZeroFloat</dt>
<dd><p>Represents the invariant &quot;x != 0&quot; where x represents all of the elements of a sequence of
double. Prints as <code>x[] elements != 0</code>.
</p>
</dd>
<dt>EltOneOf</dt>
<dd><p>Represents sequences of long values where the elements of the sequence take on only a
few distinct values. Prints as either <code>x[] == c</code> (when there is only one value), or
as <code>x[] one of {c1, c2, c3}</code> (when there are multiple values).
</p>
<p>See also the following configuration options:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.unary.sequence.EltOneOf.size</samp>&rsquo;
    </li><li> &lsquo;<samp>daikon.inv.unary.sequence.EltOneOf.omit_hashcode_values_Simplify</samp>&rsquo;
    </li></ul>

</dd>
<dt>EltOneOfFloat</dt>
<dd><p>Represents sequences of double values where the elements of the sequence take on only a
few distinct values. Prints as either <code>x[] == c</code> (when there is only one value), or
as <code>x[] one of {c1, c2, c3}</code> (when there are multiple values).
</p>
<p>See also the following configuration option:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.unary.sequence.EltOneOfFloat.size</samp>&rsquo;
    </li></ul>

</dd>
<dt>EltOneOfString</dt>
<dd><p>Represents sequences of String values where the elements of the sequence take on only a
few distinct values. Prints as either <code>x[] == c</code> (when there is only one value), or
as <code>x[] one of {c1, c2, c3}</code> (when there are multiple values).
</p>
<p>See also the following configuration option:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.unary.stringsequence.EltOneOfString.size</samp>&rsquo;
    </li></ul>

</dd>
<dt>EltRangeFloat.EqualMinusOne</dt>
<dd><p>Internal invariant representing double scalars that are equal to minus one. Used for
non-instantiating suppressions. Will never print since OneOf accomplishes the same thing.
</p>
</dd>
<dt>EltRangeFloat.EqualOne</dt>
<dd><p>Internal invariant representing double scalars that are equal to one. Used for
non-instantiating suppressions. Will never print since OneOf accomplishes the same thing.
</p>
</dd>
<dt>EltRangeFloat.EqualZero</dt>
<dd><p>Internal invariant representing double scalars that are equal to zero. Used for
non-instantiating suppressions. Will never print since OneOf accomplishes the same thing.
</p>
</dd>
<dt>EltRangeFloat.GreaterEqual64</dt>
<dd><p>Internal invariant representing double scalars that are greater than or equal to 64. Used
for non-instantiating suppressions. Will never print since Bound accomplishes the same thing.
</p>
</dd>
<dt>EltRangeFloat.GreaterEqualZero</dt>
<dd><p>Internal invariant representing double scalars that are greater than or equal to 0. Used
for non-instantiating suppressions. Will never print since Bound accomplishes the same thing.
</p>
</dd>
<dt>EltRangeInt.BooleanVal</dt>
<dd><p>Internal invariant representing longs whose values are always 0 or 1. Used for
non-instantiating suppressions. Will never print since OneOf accomplishes the same thing.
</p>
</dd>
<dt>EltRangeInt.Bound0_63</dt>
<dd><p>Internal invariant representing longs whose values are between 0 and 63. Used for
non-instantiating suppressions. Will never print since Bound accomplishes the same thing.
</p>
</dd>
<dt>EltRangeInt.EqualMinusOne</dt>
<dd><p>Internal invariant representing long scalars that are equal to minus one. Used for
non-instantiating suppressions. Will never print since OneOf accomplishes the same thing.
</p>
</dd>
<dt>EltRangeInt.EqualOne</dt>
<dd><p>Internal invariant representing long scalars that are equal to one. Used for
non-instantiating suppressions. Will never print since OneOf accomplishes the same thing.
</p>
</dd>
<dt>EltRangeInt.EqualZero</dt>
<dd><p>Internal invariant representing long scalars that are equal to zero. Used for
non-instantiating suppressions. Will never print since OneOf accomplishes the same thing.
</p>
</dd>
<dt>EltRangeInt.Even</dt>
<dd><p>Invariant representing longs whose values are always even. Used for non-instantiating
suppressions. Since this is not covered by the Bound or OneOf invariants it is printed. Prints
as <code>x is even</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.sequence.EltRangeInt.Even.enabled</samp>&rsquo;.
</p>
</dd>
<dt>EltRangeInt.GreaterEqual64</dt>
<dd><p>Internal invariant representing long scalars that are greater than or equal to 64. Used
for non-instantiating suppressions. Will never print since Bound accomplishes the same thing.
</p>
</dd>
<dt>EltRangeInt.GreaterEqualZero</dt>
<dd><p>Internal invariant representing long scalars that are greater than or equal to 0. Used
for non-instantiating suppressions. Will never print since Bound accomplishes the same thing.
</p>
</dd>
<dt>EltRangeInt.PowerOfTwo</dt>
<dd><p>Invariant representing longs whose values are always a power of 2 (exactly one bit is set).
Used for non-instantiating suppressions. Since this is not covered by the Bound or OneOf
invariants it is printed. Prints as <code>x is a power of 2</code>.
</p>
</dd>
<dt>EltUpperBound</dt>
<dd><p>Represents the invariant that each element of a sequence of long values is less than or
equal to a constant. Prints as <code>x[] elements &lt;= c</code>.
</p>
<p>See also the following configuration options:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.unary.sequence.EltUpperBound.minimal_interesting</samp>&rsquo;
    </li><li> &lsquo;<samp>daikon.inv.unary.sequence.EltUpperBound.maximal_interesting</samp>&rsquo;
    </li></ul>

</dd>
<dt>EltUpperBoundFloat</dt>
<dd><p>Represents the invariant that each element of a sequence of double values is less than or
equal to a constant. Prints as <code>x[] elements &lt;= c</code>.
</p>
<p>See also the following configuration options:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.unary.sequence.EltUpperBoundFloat.minimal_interesting</samp>&rsquo;
    </li><li> &lsquo;<samp>daikon.inv.unary.sequence.EltUpperBoundFloat.maximal_interesting</samp>&rsquo;
    </li></ul>

</dd>
<dt>EltwiseFloatEqual</dt>
<dd><p>Represents equality between adjacent elements (x[i], x[i+1]) of a double sequence. Prints as
<code>x[] elements are equal</code>.
</p>
</dd>
<dt>EltwiseFloatGreaterEqual</dt>
<dd><p>Represents the invariant &gt;= between adjacent elements
(x[i], x[i+1]) of a double sequence. Prints as
<code>x[] sorted by &gt;=</code>.
</p>
</dd>
<dt>EltwiseFloatGreaterThan</dt>
<dd><p>Represents the invariant &gt; between adjacent elements
(x[i], x[i+1]) of a double sequence. Prints as
<code>x[] sorted by &gt;</code>.
</p>
</dd>
<dt>EltwiseFloatLessEqual</dt>
<dd><p>Represents the invariant &lt;= between adjacent elements
(x[i], x[i+1]) of a double sequence. Prints as
<code>x[] sorted by &lt;=</code>.
</p>
</dd>
<dt>EltwiseFloatLessThan</dt>
<dd><p>Represents the invariant &lt; between adjacent elements
(x[i], x[i+1]) of a double sequence. Prints as
<code>x[] sorted by &lt;</code>.
</p>
</dd>
<dt>EltwiseIntEqual</dt>
<dd><p>Represents equality between adjacent elements (x[i], x[i+1]) of a long sequence. Prints as
<code>x[] elements are equal</code>.
</p>
</dd>
<dt>EltwiseIntGreaterEqual</dt>
<dd><p>Represents the invariant &gt;= between adjacent elements
(x[i], x[i+1]) of a long sequence. Prints as
<code>x[] sorted by &gt;=</code>.
</p>
</dd>
<dt>EltwiseIntGreaterThan</dt>
<dd><p>Represents the invariant &gt; between adjacent elements
(x[i], x[i+1]) of a long sequence. Prints as
<code>x[] sorted by &gt;</code>.
</p>
</dd>
<dt>EltwiseIntLessEqual</dt>
<dd><p>Represents the invariant &lt;= between adjacent elements
(x[i], x[i+1]) of a long sequence. Prints as
<code>x[] sorted by &lt;=</code>.
</p>
</dd>
<dt>EltwiseIntLessThan</dt>
<dd><p>Represents the invariant &lt; between adjacent elements
(x[i], x[i+1]) of a long sequence. Prints as
<code>x[] sorted by &lt;</code>.
</p>
</dd>
<dt>Equality</dt>
<dd><p>Keeps track of sets of variables that are equal. Other invariants are instantiated for only one
member of the Equality set, the leader. If variables <code>x</code>, <code>y</code>, and <code>z</code> are
members of the Equality set and <code>x</code> is chosen as the leader, then the Equality will
internally convert into binary comparison invariants that print as <code>x == y</code> and <code>x ==
 z</code>.
</p>
</dd>
<dt>FloatEqual</dt>
<dd><p>Represents an invariant of == between two double scalars. Prints as <code>x == y</code>.
</p>
</dd>
<dt>FloatGreaterEqual</dt>
<dd><p>Represents an invariant of &gt;= between two double scalars. Prints as <code>x &gt;= y</code>.
</p>
</dd>
<dt>FloatGreaterThan</dt>
<dd><p>Represents an invariant of &gt; between two double scalars. Prints as <code>x &gt; y</code>.
</p>
</dd>
<dt>FloatLessEqual</dt>
<dd><p>Represents an invariant of &lt;= between two double scalars. Prints as <code>x &lt;= y</code>.
</p>
</dd>
<dt>FloatLessThan</dt>
<dd><p>Represents an invariant of &lt; between two double scalars. Prints as <code>x &lt; y</code>.
</p>
</dd>
<dt>FloatNonEqual</dt>
<dd><p>Represents an invariant of != between two double scalars. Prints as <code>x != y</code>.
</p>
</dd>
<dt>FunctionBinary.BitwiseAndLong_{xyz, yxz, zxy}</dt>
<dd><p>Represents the invariant <code>x = BitwiseAnd(y, z)</code> over three long
scalars.
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.
</p>
</dd>
<dt>FunctionBinary.BitwiseOrLong_{xyz, yxz, zxy}</dt>
<dd><p>Represents the invariant <code>x = BitwiseOr(y, z)</code> over three long
scalars.
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.
</p>
</dd>
<dt>FunctionBinary.BitwiseXorLong_{xyz, yxz, zxy}</dt>
<dd><p>Represents the invariant <code>x = BitwiseXor(y, z)</code> over three long
scalars.
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.
</p>
</dd>
<dt>FunctionBinary.DivisionLong_{xyz, xzy, yxz, yzx, zxy, zyx}</dt>
<dd><p>Represents the invariant <code>x = Division(y, z)</code> over three long
scalars.
Since the function is non-symmetric, all six permutations of the variables are checked.
</p>
</dd>
<dt>FunctionBinary.GcdLong_{xyz, yxz, zxy}</dt>
<dd><p>Represents the invariant <code>x = Gcd(y, z)</code> over three long
scalars.
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.
</p>
</dd>
<dt>FunctionBinary.LogicalAndLong_{xyz, yxz, zxy}</dt>
<dd><p>Represents the invariant <code>x = LogicalAnd(y, z)</code> over three long
scalars. For logical operations, Daikon treats 0 as false and all other values as true.
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.
</p>
</dd>
<dt>FunctionBinary.LogicalOrLong_{xyz, yxz, zxy}</dt>
<dd><p>Represents the invariant <code>x = LogicalOr(y, z)</code> over three long
scalars. For logical operations, Daikon treats 0 as false and all other values as true.
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.
</p>
</dd>
<dt>FunctionBinary.LogicalXorLong_{xyz, yxz, zxy}</dt>
<dd><p>Represents the invariant <code>x = LogicalXor(y, z)</code> over three long
scalars. For logical operations, Daikon treats 0 as false and all other values as true.
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.
</p>
</dd>
<dt>FunctionBinary.LshiftLong_{xyz, xzy, yxz, yzx, zxy, zyx}</dt>
<dd><p>Represents the invariant <code>x = Lshift(y, z)</code> over three long
scalars.
Since the function is non-symmetric, all six permutations of the variables are checked.
</p>
</dd>
<dt>FunctionBinary.MaximumLong_{xyz, yxz, zxy}</dt>
<dd><p>Represents the invariant <code>x = Maximum(y, z)</code> over three long
scalars.
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.
</p>
</dd>
<dt>FunctionBinary.MinimumLong_{xyz, yxz, zxy}</dt>
<dd><p>Represents the invariant <code>x = Minimum(y, z)</code> over three long
scalars.
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.
</p>
</dd>
<dt>FunctionBinary.ModLong_{xyz, xzy, yxz, yzx, zxy, zyx}</dt>
<dd><p>Represents the invariant <code>x = Mod(y, z)</code> over three long
scalars.
Since the function is non-symmetric, all six permutations of the variables are checked.
</p>
</dd>
<dt>FunctionBinary.MultiplyLong_{xyz, yxz, zxy}</dt>
<dd><p>Represents the invariant <code>x = Multiply(y, z)</code> over three long
scalars.
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.
</p>
</dd>
<dt>FunctionBinary.PowerLong_{xyz, xzy, yxz, yzx, zxy, zyx}</dt>
<dd><p>Represents the invariant <code>x = Power(y, z)</code> over three long
scalars.
Since the function is non-symmetric, all six permutations of the variables are checked.
</p>
</dd>
<dt>FunctionBinary.RshiftSignedLong_{xyz, xzy, yxz, yzx, zxy, zyx}</dt>
<dd><p>Represents the invariant <code>x = RshiftSigned(y, z)</code> over three long
scalars.
Since the function is non-symmetric, all six permutations of the variables are checked.
</p>
</dd>
<dt>FunctionBinary.RshiftUnsignedLong_{xyz, xzy, yxz, yzx, zxy, zyx}</dt>
<dd><p>Represents the invariant <code>x = RshiftUnsigned(y, z)</code> over three long
scalars.
Since the function is non-symmetric, all six permutations of the variables are checked.
</p>
</dd>
<dt>FunctionBinaryFloat.DivisionDouble_{xyz, xzy, yxz, yzx, zxy, zyx}</dt>
<dd><p>Represents the invariant <code>x = Division(y, z)</code> over three double
scalars.
Since the function is non-symmetric, all six permutations of the variables are checked.
</p>
</dd>
<dt>FunctionBinaryFloat.MaximumDouble_{xyz, yxz, zxy}</dt>
<dd><p>Represents the invariant <code>x = Maximum(y, z)</code> over three double
scalars.
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.
</p>
</dd>
<dt>FunctionBinaryFloat.MinimumDouble_{xyz, yxz, zxy}</dt>
<dd><p>Represents the invariant <code>x = Minimum(y, z)</code> over three double
scalars.
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.
</p>
</dd>
<dt>FunctionBinaryFloat.MultiplyDouble_{xyz, yxz, zxy}</dt>
<dd><p>Represents the invariant <code>x = Multiply(y, z)</code> over three double
scalars.
Since the function is symmetric, only the permutations xyz, yxz, and zxy are checked.
</p>
</dd>
<dt>GuardingImplication</dt>
<dd><p>This is a special implication invariant that guards any invariants that are over variables that
are sometimes missing. For example, if the invariant <code>a.x = 0</code> is true, the guarded
implication is <code>a != null =&gt; a.x = 0</code>.
</p>
</dd>
<dt>Implication</dt>
<dd><p>The Implication invariant class is used internally within Daikon to handle invariants that are
only true when certain other conditions are also true (splitting).
</p>
</dd>
<dt>IntEqual</dt>
<dd><p>Represents an invariant of == between two long scalars. Prints as <code>x == y</code>.
</p>
</dd>
<dt>IntGreaterEqual</dt>
<dd><p>Represents an invariant of &gt;= between two long scalars. Prints as <code>x &gt;= y</code>.
</p>
</dd>
<dt>IntGreaterThan</dt>
<dd><p>Represents an invariant of &gt; between two long scalars. Prints as <code>x &gt; y</code>.
</p>
</dd>
<dt>IntLessEqual</dt>
<dd><p>Represents an invariant of &lt;= between two long scalars. Prints as <code>x &lt;= y</code>.
</p>
</dd>
<dt>IntLessThan</dt>
<dd><p>Represents an invariant of &lt; between two long scalars. Prints as <code>x &lt; y</code>.
</p>
</dd>
<dt>IntNonEqual</dt>
<dd><p>Represents an invariant of != between two long scalars. Prints as <code>x != y</code>.
</p>
<p>See also the following configuration option:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.binary.twoScalar.IntNonEqual.integral_only</samp>&rsquo;
    </li></ul>

</dd>
<dt>IsPointer</dt>
<dd><p>IsPointer is an invariant that heuristically determines whether an integer represents a pointer
(a 32-bit memory address). Since both a 32-bit integer and an address have the same
representation, sometimes a a pointer can be mistaken for an integer. When this happens, several
scalar invariants are computed for integer variables. Most of them would not make any sense for
pointers. Determining whether a 32-bit variable is a pointer can thus spare the computation of
many irrelevant invariants.
</p>
<p>The basic approach is to discard the invariant if any values that are not valid pointers are
encountered. By default values between -100,000 and 100,000 (except 0) are considered to be
invalid pointers. This approach has been experimentally confirmed on Windows x86 executables.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.scalar.IsPointer.enabled</samp>&rsquo;.
</p>
</dd>
<dt>LinearBinary</dt>
<dd><p>Represents a Linear invariant between two long scalars <code>x</code> and <code>y</code>, of
the form <code>ax + by + c = 0</code>. The constants <code>a</code>, <code>b</code> and
<code>c</code> are mutually relatively prime, and the constant <code>a</code> is always positive.
</p>
</dd>
<dt>LinearBinaryFloat</dt>
<dd><p>Represents a Linear invariant between two double scalars <code>x</code> and <code>y</code>, of
the form <code>ax + by + c = 0</code>. The constants <code>a</code>, <code>b</code> and
<code>c</code> are mutually relatively prime, and the constant <code>a</code> is always positive.
</p>
</dd>
<dt>LinearTernary</dt>
<dd><p>Represents a Linear invariant over three long scalars <code>x</code>,
<code>y</code>, and <code>z</code>, of the form
<code>ax + by + cz + d = 0</code>.
The constants <code>a</code>, <code>b</code>, <code>c</code>, and
<code>d</code> are mutually relatively prime, and the constant
<code>a</code> is always positive.
</p>
</dd>
<dt>LinearTernaryFloat</dt>
<dd><p>Represents a Linear invariant over three double scalars <code>x</code>,
<code>y</code>, and <code>z</code>, of the form
<code>ax + by + cz + d = 0</code>.
The constants <code>a</code>, <code>b</code>, <code>c</code>, and
<code>d</code> are mutually relatively prime, and the constant
<code>a</code> is always positive.
</p>
</dd>
<dt>LowerBound</dt>
<dd><p>Represents the invariant <code>x &gt;= c</code>, where <code>c</code> is a constant and
<code>x</code> is a long scalar.
</p>
<p>See also the following configuration options:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.unary.scalar.LowerBound.minimal_interesting</samp>&rsquo;
    </li><li> &lsquo;<samp>daikon.inv.unary.scalar.LowerBound.maximal_interesting</samp>&rsquo;
    </li></ul>

</dd>
<dt>LowerBoundFloat</dt>
<dd><p>Represents the invariant <code>x &gt;= c</code>, where <code>c</code> is a constant and
<code>x</code> is a double scalar.
</p>
<p>See also the following configuration options:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.unary.scalar.LowerBoundFloat.minimal_interesting</samp>&rsquo;
    </li><li> &lsquo;<samp>daikon.inv.unary.scalar.LowerBoundFloat.maximal_interesting</samp>&rsquo;
    </li></ul>

</dd>
<dt>Member</dt>
<dd><p>Represents long scalars that are always members of a sequence of long values. Prints as
<code>x in y[]</code> where <code>x</code> is a long scalar and <code>y[]</code> is a sequence
of long.
</p>
</dd>
<dt>MemberFloat</dt>
<dd><p>Represents double scalars that are always members of a sequence of double values. Prints as
<code>x in y[]</code> where <code>x</code> is a double scalar and <code>y[]</code> is a sequence
of double.
</p>
</dd>
<dt>MemberString</dt>
<dd><p>Represents String scalars that are always members of a sequence of String values. Prints as
<code>x in y[]</code> where <code>x</code> is a String scalar and <code>y[]</code> is a sequence
of String.
</p>
</dd>
<dt>Modulus</dt>
<dd><p>Represents the invariant <code>x == r (mod m)</code> where <code>x</code> is a long scalar variable, <code>r</code> is the (constant) remainder, and <code>m</code> is the (constant) modulus.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.scalar.Modulus.enabled</samp>&rsquo;.
</p>
</dd>
<dt>NoDuplicates</dt>
<dd><p>Represents sequences of long that contain no duplicate elements. Prints as
<code>x[] contains no duplicates</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.sequence.NoDuplicates.enabled</samp>&rsquo;.
</p>
</dd>
<dt>NoDuplicatesFloat</dt>
<dd><p>Represents sequences of double that contain no duplicate elements. Prints as
<code>x[] contains no duplicates</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.sequence.NoDuplicatesFloat.enabled</samp>&rsquo;.
</p>
</dd>
<dt>NonModulus</dt>
<dd><p>Represents long scalars that are never equal to <code>r (mod m)</code> where all other numbers in the
same range (i.e., all the values that <code>x</code> doesn&rsquo;t take from <code>min(x)</code> to <code>max(x)</code>) are equal to <code>r (mod m)</code>. Prints as <code>x != r (mod m)</code>, where <code>r</code> is the
remainder and <code>m</code> is the modulus.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.scalar.NonModulus.enabled</samp>&rsquo;.
</p>
</dd>
<dt>NonZero</dt>
<dd><p>Represents long scalars that are non-zero. Prints as <code>x != 0</code>, or as <code>x !=
null</code> for pointer types.
</p>
</dd>
<dt>NonZeroFloat</dt>
<dd><p>Represents double scalars that are non-zero. Prints as <code>x != 0</code>.
</p>
</dd>
<dt>NumericFloat.Divides</dt>
<dd><p>Represents the divides without remainder invariant between two double scalars.
Prints as <code>x % y == 0</code>.
</p>
</dd>
<dt>NumericFloat.Square</dt>
<dd><p>Represents the square invariant between two double scalars.
Prints as <code>x = y**2</code>.
</p>
</dd>
<dt>NumericFloat.ZeroTrack</dt>
<dd><p>Represents the zero tracks invariant between
two double scalars; that is, when <code>x</code> is zero,
<code>y</code> is also zero.
Prints as <code>x = 0 =&gt; y = 0</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoScalar.NumericFloat.ZeroTrack.enabled</samp>&rsquo;.
</p>
</dd>
<dt>NumericInt.BitwiseAndZero</dt>
<dd><p>Represents the BitwiseAnd == 0 invariant between two long scalars; that is, <code>x</code> and
<code>y</code> have no bits in common.
Prints as <code>x &amp; y == 0</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoScalar.NumericInt.BitwiseAndZero.enabled</samp>&rsquo;.
</p>
</dd>
<dt>NumericInt.BitwiseComplement</dt>
<dd><p>Represents the bitwise complement invariant between two long scalars.
Prints as <code>x = ~y</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoScalar.NumericInt.BitwiseComplement.enabled</samp>&rsquo;.
</p>
</dd>
<dt>NumericInt.BitwiseSubset</dt>
<dd><p>Represents the bitwise subset invariant between two long scalars; that is, the bits of
<code>y</code> are a subset of the bits of <code>x</code>.
Prints as <code>x = y | x</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoScalar.NumericInt.BitwiseSubset.enabled</samp>&rsquo;.
</p>
</dd>
<dt>NumericInt.Divides</dt>
<dd><p>Represents the divides without remainder invariant between two long scalars.
Prints as <code>x % y == 0</code>.
</p>
</dd>
<dt>NumericInt.ShiftZero</dt>
<dd><p>Represents the ShiftZero invariant between two long scalars; that is, <code>x</code>
right-shifted by <code>y</code> is always zero.
Prints as <code>x &gt;&gt; y = 0</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoScalar.NumericInt.ShiftZero.enabled</samp>&rsquo;.
</p>
</dd>
<dt>NumericInt.Square</dt>
<dd><p>Represents the square invariant between two long scalars.
Prints as <code>x = y**2</code>.
</p>
</dd>
<dt>NumericInt.ZeroTrack</dt>
<dd><p>Represents the zero tracks invariant between
two long scalars; that is, when <code>x</code> is zero,
<code>y</code> is also zero.
Prints as <code>x = 0 =&gt; y = 0</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoScalar.NumericInt.ZeroTrack.enabled</samp>&rsquo;.
</p>
</dd>
<dt>OneOfFloat</dt>
<dd><p>Represents double variables that take on only a few distinct values. Prints as either
<code>x == c</code> (when there is only one value) or as <code>x one of {c1, c2, c3}</code>
(when there are multiple values).
</p>
<p>See also the following configuration option:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.unary.scalar.OneOfFloat.size</samp>&rsquo;
    </li></ul>

</dd>
<dt>OneOfFloatSequence</dt>
<dd><p>Represents double[] variables that take on only a few distinct values. Prints as either
<code>x == c</code> (when there is only one value) or as <code>x one of {c1, c2, c3}</code>
(when there are multiple values).
</p>
<p>See also the following configuration option:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.unary.sequence.OneOfFloatSequence.size</samp>&rsquo;
    </li></ul>

</dd>
<dt>OneOfScalar</dt>
<dd><p>Represents long scalars that take on only a few distinct values. Prints as either
<code>x == c</code> (when there is only one value), <code>x one of {c1, c2, c3}</code> (when
there are multiple values), or <code>x has only one value</code> (when <code>x</code> is a
hashcode (pointer) &ndash; this is because the numerical value of the hashcode (pointer) is
uninteresting).
</p>
<p>See also the following configuration options:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.unary.scalar.OneOfScalar.size</samp>&rsquo;
    </li><li> &lsquo;<samp>daikon.inv.unary.scalar.OneOfScalar.omit_hashcode_values_Simplify</samp>&rsquo;
    </li></ul>

</dd>
<dt>OneOfSequence</dt>
<dd><p>Represents long[] variables that take on only a few distinct values. Prints as either
<code>x == c</code> (when there is only one value) or as <code>x one of {c1, c2, c3}</code>
(when there are multiple values).
</p>
<p>See also the following configuration options:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.unary.sequence.OneOfSequence.size</samp>&rsquo;
    </li><li> &lsquo;<samp>daikon.inv.unary.sequence.OneOfSequence.omit_hashcode_values_Simplify</samp>&rsquo;
    </li></ul>

</dd>
<dt>OneOfString</dt>
<dd><p>Represents String variables that take on only a few distinct values. Prints as either
<code>x == c</code> (when there is only one value) or as <code>x one of {c1, c2, c3}</code>
(when there are multiple values).
</p>
<p>See also the following configuration option:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.unary.string.OneOfString.size</samp>&rsquo;
    </li></ul>

</dd>
<dt>OneOfStringSequence</dt>
<dd><p>Represents String[] variables that take on only a few distinct values. Prints as either
<code>x == c</code> (when there is only one value) or as <code>x one of {c1, c2, c3}</code>
(when there are multiple values).
</p>
<p>See also the following configuration option:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.unary.stringsequence.OneOfStringSequence.size</samp>&rsquo;
    </li></ul>

</dd>
<dt>PairwiseFloatEqual</dt>
<dd><p>Represents an invariant between corresponding elements of two sequences of double values. The
length of the sequences must match for the invariant to hold. A comparison is made over each
<code>(x[i], y[i])</code> pair. Thus, <code>x[0]</code> is compared to <code>y[0]</code>,
<code>x[1]</code> to <code>y[1]</code>, and so forth. Prints as <code>x[] == y[]</code>.
</p>
</dd>
<dt>PairwiseFloatGreaterEqual</dt>
<dd><p>Represents an invariant between corresponding elements of two sequences of double values. The
length of the sequences must match for the invariant to hold. A comparison is made over each
<code>(x[i], y[i])</code> pair. Thus, <code>x[0]</code> is compared to <code>y[0]</code>,
<code>x[1]</code> to <code>y[1]</code>, and so forth. Prints as <code>x[] &gt;= y[]</code>.
</p>
</dd>
<dt>PairwiseFloatGreaterThan</dt>
<dd><p>Represents an invariant between corresponding elements of two sequences of double values. The
length of the sequences must match for the invariant to hold. A comparison is made over each
<code>(x[i], y[i])</code> pair. Thus, <code>x[0]</code> is compared to <code>y[0]</code>,
<code>x[1]</code> to <code>y[1]</code>, and so forth. Prints as <code>x[] &gt; y[]</code>.
</p>
</dd>
<dt>PairwiseFloatLessEqual</dt>
<dd><p>Represents an invariant between corresponding elements of two sequences of double values. The
length of the sequences must match for the invariant to hold. A comparison is made over each
<code>(x[i], y[i])</code> pair. Thus, <code>x[0]</code> is compared to <code>y[0]</code>,
<code>x[1]</code> to <code>y[1]</code>, and so forth. Prints as <code>x[] &lt;= y[]</code>.
</p>
</dd>
<dt>PairwiseFloatLessThan</dt>
<dd><p>Represents an invariant between corresponding elements of two sequences of double values. The
length of the sequences must match for the invariant to hold. A comparison is made over each
<code>(x[i], y[i])</code> pair. Thus, <code>x[0]</code> is compared to <code>y[0]</code>,
<code>x[1]</code> to <code>y[1]</code>, and so forth. Prints as <code>x[] &lt; y[]</code>.
</p>
</dd>
<dt>PairwiseIntEqual</dt>
<dd><p>Represents an invariant between corresponding elements of two sequences of long values. The
length of the sequences must match for the invariant to hold. A comparison is made over each
<code>(x[i], y[i])</code> pair. Thus, <code>x[0]</code> is compared to <code>y[0]</code>,
<code>x[1]</code> to <code>y[1]</code>, and so forth. Prints as <code>x[] == y[]</code>.
</p>
</dd>
<dt>PairwiseIntGreaterEqual</dt>
<dd><p>Represents an invariant between corresponding elements of two sequences of long values. The
length of the sequences must match for the invariant to hold. A comparison is made over each
<code>(x[i], y[i])</code> pair. Thus, <code>x[0]</code> is compared to <code>y[0]</code>,
<code>x[1]</code> to <code>y[1]</code>, and so forth. Prints as <code>x[] &gt;= y[]</code>.
</p>
</dd>
<dt>PairwiseIntGreaterThan</dt>
<dd><p>Represents an invariant between corresponding elements of two sequences of long values. The
length of the sequences must match for the invariant to hold. A comparison is made over each
<code>(x[i], y[i])</code> pair. Thus, <code>x[0]</code> is compared to <code>y[0]</code>,
<code>x[1]</code> to <code>y[1]</code>, and so forth. Prints as <code>x[] &gt; y[]</code>.
</p>
</dd>
<dt>PairwiseIntLessEqual</dt>
<dd><p>Represents an invariant between corresponding elements of two sequences of long values. The
length of the sequences must match for the invariant to hold. A comparison is made over each
<code>(x[i], y[i])</code> pair. Thus, <code>x[0]</code> is compared to <code>y[0]</code>,
<code>x[1]</code> to <code>y[1]</code>, and so forth. Prints as <code>x[] &lt;= y[]</code>.
</p>
</dd>
<dt>PairwiseIntLessThan</dt>
<dd><p>Represents an invariant between corresponding elements of two sequences of long values. The
length of the sequences must match for the invariant to hold. A comparison is made over each
<code>(x[i], y[i])</code> pair. Thus, <code>x[0]</code> is compared to <code>y[0]</code>,
<code>x[1]</code> to <code>y[1]</code>, and so forth. Prints as <code>x[] &lt; y[]</code>.
</p>
</dd>
<dt>PairwiseLinearBinary</dt>
<dd><p>Represents a linear invariant (i.e., <code>y = ax + b</code>) between the corresponding elements
of two sequences of long values. Each <code>(x[i], y[i])</code> pair is examined. Thus,
<code>x[0]</code> is compared to <code>y[0]</code>, <code>x[1]</code> to <code>y[1]</code> and so
forth. Prints as <code>y[] = a * x[] + b</code>.
</p>
</dd>
<dt>PairwiseLinearBinaryFloat</dt>
<dd><p>Represents a linear invariant (i.e., <code>y = ax + b</code>) between the corresponding elements
of two sequences of double values. Each <code>(x[i], y[i])</code> pair is examined. Thus,
<code>x[0]</code> is compared to <code>y[0]</code>, <code>x[1]</code> to <code>y[1]</code> and so
forth. Prints as <code>y[] = a * x[] + b</code>.
</p>
</dd>
<dt>PairwiseNumericFloat.Divides</dt>
<dd><p>Represents the divides without remainder invariant between corresponding elements of two sequences of double.
Prints as <code>x[] % y[] == 0</code>.
</p>
</dd>
<dt>PairwiseNumericFloat.Square</dt>
<dd><p>Represents the square invariant between corresponding elements of two sequences of double.
Prints as <code>x[] = y[]**2</code>.
</p>
</dd>
<dt>PairwiseNumericFloat.ZeroTrack</dt>
<dd><p>Represents the zero tracks invariant between
corresponding elements of two sequences of double; that is, when <code>x[]</code> is zero,
<code>y[]</code> is also zero.
Prints as <code>x[] = 0 =&gt; y[] = 0</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoSequence.PairwiseNumericFloat.ZeroTrack.enabled</samp>&rsquo;.
</p>
</dd>
<dt>PairwiseNumericInt.BitwiseAndZero</dt>
<dd><p>Represents the BitwiseAnd == 0 invariant between corresponding elements of two sequences of long; that is, <code>x[]</code> and
<code>y[]</code> have no bits in common.
Prints as <code>x[] &amp; y[] == 0</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoSequence.PairwiseNumericInt.BitwiseAndZero.enabled</samp>&rsquo;.
</p>
</dd>
<dt>PairwiseNumericInt.BitwiseComplement</dt>
<dd><p>Represents the bitwise complement invariant between corresponding elements of two sequences of long.
Prints as <code>x[] = ~y[]</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoSequence.PairwiseNumericInt.BitwiseComplement.enabled</samp>&rsquo;.
</p>
</dd>
<dt>PairwiseNumericInt.BitwiseSubset</dt>
<dd><p>Represents the bitwise subset invariant between corresponding elements of two sequences of long; that is, the bits of
<code>y[]</code> are a subset of the bits of <code>x[]</code>.
Prints as <code>x[] = y[] | x[]</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoSequence.PairwiseNumericInt.BitwiseSubset.enabled</samp>&rsquo;.
</p>
</dd>
<dt>PairwiseNumericInt.Divides</dt>
<dd><p>Represents the divides without remainder invariant between corresponding elements of two sequences of long.
Prints as <code>x[] % y[] == 0</code>.
</p>
</dd>
<dt>PairwiseNumericInt.ShiftZero</dt>
<dd><p>Represents the ShiftZero invariant between corresponding elements of two sequences of long; that is, <code>x[]</code>
right-shifted by <code>y[]</code> is always zero.
Prints as <code>x[] &gt;&gt; y[] = 0</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoSequence.PairwiseNumericInt.ShiftZero.enabled</samp>&rsquo;.
</p>
</dd>
<dt>PairwiseNumericInt.Square</dt>
<dd><p>Represents the square invariant between corresponding elements of two sequences of long.
Prints as <code>x[] = y[]**2</code>.
</p>
</dd>
<dt>PairwiseNumericInt.ZeroTrack</dt>
<dd><p>Represents the zero tracks invariant between
corresponding elements of two sequences of long; that is, when <code>x[]</code> is zero,
<code>y[]</code> is also zero.
Prints as <code>x[] = 0 =&gt; y[] = 0</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoSequence.PairwiseNumericInt.ZeroTrack.enabled</samp>&rsquo;.
</p>
</dd>
<dt>PairwiseString.SubString</dt>
<dd><p>Represents the substring invariant between corresponding elements of two sequences of String.
Prints as <code>x[] is a substring of y[]</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoSequence.PairwiseString.SubString.enabled</samp>&rsquo;.
</p>
</dd>
<dt>PairwiseStringEqual</dt>
<dd><p>Represents an invariant between corresponding elements of two sequences of String values. The
length of the sequences must match for the invariant to hold. A comparison is made over each
<code>(x[i], y[i])</code> pair. Thus, <code>x[0]</code> is compared to <code>y[0]</code>,
<code>x[1]</code> to <code>y[1]</code>, and so forth. Prints as <code>x[] == y[]</code>.
</p>
</dd>
<dt>PairwiseStringGreaterEqual</dt>
<dd><p>Represents an invariant between corresponding elements of two sequences of String values. The
length of the sequences must match for the invariant to hold. A comparison is made over each
<code>(x[i], y[i])</code> pair. Thus, <code>x[0]</code> is compared to <code>y[0]</code>,
<code>x[1]</code> to <code>y[1]</code>, and so forth. Prints as <code>x[] &gt;= y[]</code>.
</p>
</dd>
<dt>PairwiseStringGreaterThan</dt>
<dd><p>Represents an invariant between corresponding elements of two sequences of String values. The
length of the sequences must match for the invariant to hold. A comparison is made over each
<code>(x[i], y[i])</code> pair. Thus, <code>x[0]</code> is compared to <code>y[0]</code>,
<code>x[1]</code> to <code>y[1]</code>, and so forth. Prints as <code>x[] &gt; y[]</code>.
</p>
</dd>
<dt>PairwiseStringLessEqual</dt>
<dd><p>Represents an invariant between corresponding elements of two sequences of String values. The
length of the sequences must match for the invariant to hold. A comparison is made over each
<code>(x[i], y[i])</code> pair. Thus, <code>x[0]</code> is compared to <code>y[0]</code>,
<code>x[1]</code> to <code>y[1]</code>, and so forth. Prints as <code>x[] &lt;= y[]</code>.
</p>
</dd>
<dt>PairwiseStringLessThan</dt>
<dd><p>Represents an invariant between corresponding elements of two sequences of String values. The
length of the sequences must match for the invariant to hold. A comparison is made over each
<code>(x[i], y[i])</code> pair. Thus, <code>x[0]</code> is compared to <code>y[0]</code>,
<code>x[1]</code> to <code>y[1]</code>, and so forth. Prints as <code>x[] &lt; y[]</code>.
</p>
</dd>
<dt>Positive</dt>
<dd><p>Represents the invariant <code>x &gt; 0</code> where <code>x</code> is a long scalar. This exists only as an
example for the purposes of the manual. It isn&rsquo;t actually used (it is replaced by the more
general invariant LowerBound).
</p>
</dd>
<dt>PrintableString</dt>
<dd><p>Represents a string that contains only printable ascii characters (values 32 through 126 plus 9
(tab).
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.string.PrintableString.enabled</samp>&rsquo;.
</p>
</dd>
<dt>RangeFloat.EqualMinusOne</dt>
<dd><p>Internal invariant representing double scalars that are equal to minus one. Used for
non-instantiating suppressions. Will never print since OneOf accomplishes the same thing.
</p>
</dd>
<dt>RangeFloat.EqualOne</dt>
<dd><p>Internal invariant representing double scalars that are equal to one. Used for
non-instantiating suppressions. Will never print since OneOf accomplishes the same thing.
</p>
</dd>
<dt>RangeFloat.EqualZero</dt>
<dd><p>Internal invariant representing double scalars that are equal to zero. Used for
non-instantiating suppressions. Will never print since OneOf accomplishes the same thing.
</p>
</dd>
<dt>RangeFloat.GreaterEqual64</dt>
<dd><p>Internal invariant representing double scalars that are greater than or equal to 64. Used
for non-instantiating suppressions. Will never print since Bound accomplishes the same thing.
</p>
</dd>
<dt>RangeFloat.GreaterEqualZero</dt>
<dd><p>Internal invariant representing double scalars that are greater than or equal to 0. Used
for non-instantiating suppressions. Will never print since Bound accomplishes the same thing.
</p>
</dd>
<dt>RangeInt.BooleanVal</dt>
<dd><p>Internal invariant representing longs whose values are always 0 or 1. Used for
non-instantiating suppressions. Will never print since OneOf accomplishes the same thing.
</p>
</dd>
<dt>RangeInt.Bound0_63</dt>
<dd><p>Internal invariant representing longs whose values are between 0 and 63. Used for
non-instantiating suppressions. Will never print since Bound accomplishes the same thing.
</p>
</dd>
<dt>RangeInt.EqualMinusOne</dt>
<dd><p>Internal invariant representing long scalars that are equal to minus one. Used for
non-instantiating suppressions. Will never print since OneOf accomplishes the same thing.
</p>
</dd>
<dt>RangeInt.EqualOne</dt>
<dd><p>Internal invariant representing long scalars that are equal to one. Used for
non-instantiating suppressions. Will never print since OneOf accomplishes the same thing.
</p>
</dd>
<dt>RangeInt.EqualZero</dt>
<dd><p>Internal invariant representing long scalars that are equal to zero. Used for
non-instantiating suppressions. Will never print since OneOf accomplishes the same thing.
</p>
</dd>
<dt>RangeInt.Even</dt>
<dd><p>Invariant representing longs whose values are always even. Used for non-instantiating
suppressions. Since this is not covered by the Bound or OneOf invariants it is printed. Prints
as <code>x is even</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.scalar.RangeInt.Even.enabled</samp>&rsquo;.
</p>
</dd>
<dt>RangeInt.GreaterEqual64</dt>
<dd><p>Internal invariant representing long scalars that are greater than or equal to 64. Used
for non-instantiating suppressions. Will never print since Bound accomplishes the same thing.
</p>
</dd>
<dt>RangeInt.GreaterEqualZero</dt>
<dd><p>Internal invariant representing long scalars that are greater than or equal to 0. Used
for non-instantiating suppressions. Will never print since Bound accomplishes the same thing.
</p>
</dd>
<dt>RangeInt.PowerOfTwo</dt>
<dd><p>Invariant representing longs whose values are always a power of 2 (exactly one bit is set).
Used for non-instantiating suppressions. Since this is not covered by the Bound or OneOf
invariants it is printed. Prints as <code>x is a power of 2</code>.
</p>
</dd>
<dt>Reverse</dt>
<dd><p>Represents two sequences of long where one is in the reverse order of the other. Prints as
<code>x[] is the reverse of y[]</code>.
</p>
</dd>
<dt>ReverseFloat</dt>
<dd><p>Represents two sequences of double where one is in the reverse order of the other. Prints as
<code>x[] is the reverse of y[]</code>.
</p>
</dd>
<dt>SeqFloatEqual</dt>
<dd><p>Represents an invariant between a double scalar and a a sequence of double values. Prints
as <code>x[] elements == y</code> where <code>x</code> is a double sequence and
<code>y</code> is a double scalar.
</p>
</dd>
<dt>SeqFloatGreaterEqual</dt>
<dd><p>Represents an invariant between a double scalar and a a sequence of double values. Prints
as <code>x[] elements &gt;= y</code> where <code>x</code> is a double sequence and
<code>y</code> is a double scalar.
</p>
</dd>
<dt>SeqFloatGreaterThan</dt>
<dd><p>Represents an invariant between a double scalar and a a sequence of double values. Prints
as <code>x[] elements &gt; y</code> where <code>x</code> is a double sequence and
<code>y</code> is a double scalar.
</p>
</dd>
<dt>SeqFloatLessEqual</dt>
<dd><p>Represents an invariant between a double scalar and a a sequence of double values. Prints
as <code>x[] elements &lt;= y</code> where <code>x</code> is a double sequence and
<code>y</code> is a double scalar.
</p>
</dd>
<dt>SeqFloatLessThan</dt>
<dd><p>Represents an invariant between a double scalar and a a sequence of double values. Prints
as <code>x[] elements &lt; y</code> where <code>x</code> is a double sequence and
<code>y</code> is a double scalar.
</p>
</dd>
<dt>SeqIndexFloatEqual</dt>
<dd><p>Represents an invariant over sequences of double values between the index of an element of the
sequence and the element itself. Prints as <code>x[i] == i</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.sequence.SeqIndexFloatEqual.enabled</samp>&rsquo;.
</p>
</dd>
<dt>SeqIndexFloatGreaterEqual</dt>
<dd><p>Represents an invariant over sequences of double values between the index of an element of the
sequence and the element itself. Prints as <code>x[i] &gt;= i</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.sequence.SeqIndexFloatGreaterEqual.enabled</samp>&rsquo;.
</p>
</dd>
<dt>SeqIndexFloatGreaterThan</dt>
<dd><p>Represents an invariant over sequences of double values between the index of an element of the
sequence and the element itself. Prints as <code>x[i] &gt; i</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.sequence.SeqIndexFloatGreaterThan.enabled</samp>&rsquo;.
</p>
</dd>
<dt>SeqIndexFloatLessEqual</dt>
<dd><p>Represents an invariant over sequences of double values between the index of an element of the
sequence and the element itself. Prints as <code>x[i] &lt;= i</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.sequence.SeqIndexFloatLessEqual.enabled</samp>&rsquo;.
</p>
</dd>
<dt>SeqIndexFloatLessThan</dt>
<dd><p>Represents an invariant over sequences of double values between the index of an element of the
sequence and the element itself. Prints as <code>x[i] &lt; i</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.sequence.SeqIndexFloatLessThan.enabled</samp>&rsquo;.
</p>
</dd>
<dt>SeqIndexFloatNonEqual</dt>
<dd><p>Represents an invariant over sequences of double values between the index of an element of the
sequence and the element itself. Prints as <code>x[i] != i</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.sequence.SeqIndexFloatNonEqual.enabled</samp>&rsquo;.
</p>
</dd>
<dt>SeqIndexIntEqual</dt>
<dd><p>Represents an invariant over sequences of long values between the index of an element of the
sequence and the element itself. Prints as <code>x[i] == i</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.sequence.SeqIndexIntEqual.enabled</samp>&rsquo;.
</p>
</dd>
<dt>SeqIndexIntGreaterEqual</dt>
<dd><p>Represents an invariant over sequences of long values between the index of an element of the
sequence and the element itself. Prints as <code>x[i] &gt;= i</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.sequence.SeqIndexIntGreaterEqual.enabled</samp>&rsquo;.
</p>
</dd>
<dt>SeqIndexIntGreaterThan</dt>
<dd><p>Represents an invariant over sequences of long values between the index of an element of the
sequence and the element itself. Prints as <code>x[i] &gt; i</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.sequence.SeqIndexIntGreaterThan.enabled</samp>&rsquo;.
</p>
</dd>
<dt>SeqIndexIntLessEqual</dt>
<dd><p>Represents an invariant over sequences of long values between the index of an element of the
sequence and the element itself. Prints as <code>x[i] &lt;= i</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.sequence.SeqIndexIntLessEqual.enabled</samp>&rsquo;.
</p>
</dd>
<dt>SeqIndexIntLessThan</dt>
<dd><p>Represents an invariant over sequences of long values between the index of an element of the
sequence and the element itself. Prints as <code>x[i] &lt; i</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.sequence.SeqIndexIntLessThan.enabled</samp>&rsquo;.
</p>
</dd>
<dt>SeqIndexIntNonEqual</dt>
<dd><p>Represents an invariant over sequences of long values between the index of an element of the
sequence and the element itself. Prints as <code>x[i] != i</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.unary.sequence.SeqIndexIntNonEqual.enabled</samp>&rsquo;.
</p>
</dd>
<dt>SeqIntEqual</dt>
<dd><p>Represents an invariant between a long scalar and a a sequence of long values. Prints
as <code>x[] elements == y</code> where <code>x</code> is a long sequence and
<code>y</code> is a long scalar.
</p>
</dd>
<dt>SeqIntGreaterEqual</dt>
<dd><p>Represents an invariant between a long scalar and a a sequence of long values. Prints
as <code>x[] elements &gt;= y</code> where <code>x</code> is a long sequence and
<code>y</code> is a long scalar.
</p>
</dd>
<dt>SeqIntGreaterThan</dt>
<dd><p>Represents an invariant between a long scalar and a a sequence of long values. Prints
as <code>x[] elements &gt; y</code> where <code>x</code> is a long sequence and
<code>y</code> is a long scalar.
</p>
</dd>
<dt>SeqIntLessEqual</dt>
<dd><p>Represents an invariant between a long scalar and a a sequence of long values. Prints
as <code>x[] elements &lt;= y</code> where <code>x</code> is a long sequence and
<code>y</code> is a long scalar.
</p>
</dd>
<dt>SeqIntLessThan</dt>
<dd><p>Represents an invariant between a long scalar and a a sequence of long values. Prints
as <code>x[] elements &lt; y</code> where <code>x</code> is a long sequence and
<code>y</code> is a long scalar.
</p>
</dd>
<dt>SeqSeqFloatEqual</dt>
<dd><p>Represents invariants between two sequences of double values. If order matters for each
variable (which it does by default), then the sequences are compared lexically. Prints as
<code>x[] == y[] lexically</code>.
</p>

<p>If order doesn&rsquo;t matter for each variable, then the sequences are compared to see if they are
set equivalent. Prints as <code>x[] == y[]</code>.
</p>

<p>If the auxiliary information (e.g., order matters) doesn&rsquo;t match between two variables, then
this invariant cannot apply to those variables.
</p>
</dd>
<dt>SeqSeqFloatGreaterEqual</dt>
<dd><p>Represents invariants between two sequences of double values. If order matters for each
variable (which it does by default), then the sequences are compared lexically. Prints as
<code>x[] &gt;= y[] lexically</code>.
</p>

<p>If the auxiliary information (e.g., order matters) doesn&rsquo;t match between two variables, then
this invariant cannot apply to those variables.
</p>
</dd>
<dt>SeqSeqFloatGreaterThan</dt>
<dd><p>Represents invariants between two sequences of double values. If order matters for each
variable (which it does by default), then the sequences are compared lexically. Prints as
<code>x[] &gt; y[] lexically</code>.
</p>

<p>If the auxiliary information (e.g., order matters) doesn&rsquo;t match between two variables, then
this invariant cannot apply to those variables.
</p>
</dd>
<dt>SeqSeqFloatLessEqual</dt>
<dd><p>Represents invariants between two sequences of double values. If order matters for each
variable (which it does by default), then the sequences are compared lexically. Prints as
<code>x[] &lt;= y[] lexically</code>.
</p>

<p>If the auxiliary information (e.g., order matters) doesn&rsquo;t match between two variables, then
this invariant cannot apply to those variables.
</p>
</dd>
<dt>SeqSeqFloatLessThan</dt>
<dd><p>Represents invariants between two sequences of double values. If order matters for each
variable (which it does by default), then the sequences are compared lexically. Prints as
<code>x[] &lt; y[] lexically</code>.
</p>

<p>If the auxiliary information (e.g., order matters) doesn&rsquo;t match between two variables, then
this invariant cannot apply to those variables.
</p>
</dd>
<dt>SeqSeqIntEqual</dt>
<dd><p>Represents invariants between two sequences of long values. If order matters for each
variable (which it does by default), then the sequences are compared lexically. Prints as
<code>x[] == y[] lexically</code>.
</p>

<p>If order doesn&rsquo;t matter for each variable, then the sequences are compared to see if they are
set equivalent. Prints as <code>x[] == y[]</code>.
</p>

<p>If the auxiliary information (e.g., order matters) doesn&rsquo;t match between two variables, then
this invariant cannot apply to those variables.
</p>
</dd>
<dt>SeqSeqIntGreaterEqual</dt>
<dd><p>Represents invariants between two sequences of long values. If order matters for each
variable (which it does by default), then the sequences are compared lexically. Prints as
<code>x[] &gt;= y[] lexically</code>.
</p>

<p>If the auxiliary information (e.g., order matters) doesn&rsquo;t match between two variables, then
this invariant cannot apply to those variables.
</p>
</dd>
<dt>SeqSeqIntGreaterThan</dt>
<dd><p>Represents invariants between two sequences of long values. If order matters for each
variable (which it does by default), then the sequences are compared lexically. Prints as
<code>x[] &gt; y[] lexically</code>.
</p>

<p>If the auxiliary information (e.g., order matters) doesn&rsquo;t match between two variables, then
this invariant cannot apply to those variables.
</p>
</dd>
<dt>SeqSeqIntLessEqual</dt>
<dd><p>Represents invariants between two sequences of long values. If order matters for each
variable (which it does by default), then the sequences are compared lexically. Prints as
<code>x[] &lt;= y[] lexically</code>.
</p>

<p>If the auxiliary information (e.g., order matters) doesn&rsquo;t match between two variables, then
this invariant cannot apply to those variables.
</p>
</dd>
<dt>SeqSeqIntLessThan</dt>
<dd><p>Represents invariants between two sequences of long values. If order matters for each
variable (which it does by default), then the sequences are compared lexically. Prints as
<code>x[] &lt; y[] lexically</code>.
</p>

<p>If the auxiliary information (e.g., order matters) doesn&rsquo;t match between two variables, then
this invariant cannot apply to those variables.
</p>
</dd>
<dt>SeqSeqStringEqual</dt>
<dd><p>Represents invariants between two sequences of String values. If order matters for each
variable (which it does by default), then the sequences are compared lexically. Prints as
<code>x[] == y[] lexically</code>.
</p>

<p>If order doesn&rsquo;t matter for each variable, then the sequences are compared to see if they are
set equivalent. Prints as <code>x[] == y[]</code>.
</p>

<p>If the auxiliary information (e.g., order matters) doesn&rsquo;t match between two variables, then
this invariant cannot apply to those variables.
</p>
</dd>
<dt>SeqSeqStringGreaterEqual</dt>
<dd><p>Represents invariants between two sequences of String values. If order matters for each
variable (which it does by default), then the sequences are compared lexically. Prints as
<code>x[] &gt;= y[] lexically</code>.
</p>

<p>If the auxiliary information (e.g., order matters) doesn&rsquo;t match between two variables, then
this invariant cannot apply to those variables.
</p>
</dd>
<dt>SeqSeqStringGreaterThan</dt>
<dd><p>Represents invariants between two sequences of String values. If order matters for each
variable (which it does by default), then the sequences are compared lexically. Prints as
<code>x[] &gt; y[] lexically</code>.
</p>

<p>If the auxiliary information (e.g., order matters) doesn&rsquo;t match between two variables, then
this invariant cannot apply to those variables.
</p>
</dd>
<dt>SeqSeqStringLessEqual</dt>
<dd><p>Represents invariants between two sequences of String values. If order matters for each
variable (which it does by default), then the sequences are compared lexically. Prints as
<code>x[] &lt;= y[] lexically</code>.
</p>

<p>If the auxiliary information (e.g., order matters) doesn&rsquo;t match between two variables, then
this invariant cannot apply to those variables.
</p>
</dd>
<dt>SeqSeqStringLessThan</dt>
<dd><p>Represents invariants between two sequences of String values. If order matters for each
variable (which it does by default), then the sequences are compared lexically. Prints as
<code>x[] &lt; y[] lexically</code>.
</p>

<p>If the auxiliary information (e.g., order matters) doesn&rsquo;t match between two variables, then
this invariant cannot apply to those variables.
</p>
</dd>
<dt>StdString.SubString</dt>
<dd><p>Represents the substring invariant between two String scalars.
Prints as <code>x is a substring of y</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoString.StdString.SubString.enabled</samp>&rsquo;.
</p>
</dd>
<dt>StringEqual</dt>
<dd><p>Represents an invariant of == between two String scalars. Prints as <code>x == y</code>.
</p>
</dd>
<dt>StringGreaterEqual</dt>
<dd><p>Represents an invariant of &gt;= between two String scalars. Prints as <code>x &gt;= y</code>.
</p>
</dd>
<dt>StringGreaterThan</dt>
<dd><p>Represents an invariant of &gt; between two String scalars. Prints as <code>x &gt; y</code>.
</p>
</dd>
<dt>StringLessEqual</dt>
<dd><p>Represents an invariant of &lt;= between two String scalars. Prints as <code>x &lt;= y</code>.
</p>
</dd>
<dt>StringLessThan</dt>
<dd><p>Represents an invariant of &lt; between two String scalars. Prints as <code>x &lt; y</code>.
</p>
</dd>
<dt>StringNonEqual</dt>
<dd><p>Represents an invariant of != between two String scalars. Prints as <code>x != y</code>.
</p>
</dd>
<dt>SubSequence</dt>
<dd><p>Represents two sequences of long values where one sequence is a subsequence of the
other. Prints as <code>x[] is a subsequence of y[]</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoSequence.SubSequence.enabled</samp>&rsquo;.
</p>
</dd>
<dt>SubSequenceFloat</dt>
<dd><p>Represents two sequences of double values where one sequence is a subsequence of the
other. Prints as <code>x[] is a subsequence of y[]</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoSequence.SubSequenceFloat.enabled</samp>&rsquo;.
</p>
</dd>
<dt>SubSet</dt>
<dd><p>Represents two sequences of long values where one of the sequences is a subset of the other; that
is each element of one sequence appears in the other. Prints as either
<code>x[] is a subset of y[]</code> or as <code>x[] is a superset of y[]</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoSequence.SubSet.enabled</samp>&rsquo;.
</p>
</dd>
<dt>SubSetFloat</dt>
<dd><p>Represents two sequences of double values where one of the sequences is a subset of the other; that
is each element of one sequence appears in the other. Prints as either
<code>x[] is a subset of y[]</code> or as <code>x[] is a superset of y[]</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoSequence.SubSetFloat.enabled</samp>&rsquo;.
</p>
</dd>
<dt>SuperSequence</dt>
<dd><p>Represents two sequences of long values where one sequence is a subsequence of the
other. Prints as <code>x[] is a subsequence of y[]</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoSequence.SuperSequence.enabled</samp>&rsquo;.
</p>
</dd>
<dt>SuperSequenceFloat</dt>
<dd><p>Represents two sequences of double values where one sequence is a subsequence of the
other. Prints as <code>x[] is a subsequence of y[]</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoSequence.SuperSequenceFloat.enabled</samp>&rsquo;.
</p>
</dd>
<dt>SuperSet</dt>
<dd><p>Represents two sequences of long values where one of the sequences is a subset of the other; that
is each element of one sequence appears in the other. Prints as either
<code>x[] is a subset of y[]</code> or as <code>x[] is a superset of y[]</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoSequence.SuperSet.enabled</samp>&rsquo;.
</p>
</dd>
<dt>SuperSetFloat</dt>
<dd><p>Represents two sequences of double values where one of the sequences is a subset of the other; that
is each element of one sequence appears in the other. Prints as either
<code>x[] is a subset of y[]</code> or as <code>x[] is a superset of y[]</code>.
</p>
<p>This invariant is not enabled by default.  See the configuration option
&lsquo;<samp>daikon.inv.binary.twoSequence.SuperSetFloat.enabled</samp>&rsquo;.
</p>
</dd>
<dt>UpperBound</dt>
<dd><p>Represents the invariant <code>x &lt;= c</code>, where <code>c</code> is a constant and
<code>x</code> is a long scalar.
</p>
<p>See also the following configuration options:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.unary.scalar.UpperBound.minimal_interesting</samp>&rsquo;
    </li><li> &lsquo;<samp>daikon.inv.unary.scalar.UpperBound.maximal_interesting</samp>&rsquo;
    </li></ul>

</dd>
<dt>UpperBoundFloat</dt>
<dd><p>Represents the invariant <code>x &lt;= c</code>, where <code>c</code> is a constant and
<code>x</code> is a double scalar.
</p>
<p>See also the following configuration options:
    </p><ul>
<li> &lsquo;<samp>daikon.inv.unary.scalar.UpperBoundFloat.minimal_interesting</samp>&rsquo;
    </li><li> &lsquo;<samp>daikon.inv.unary.scalar.UpperBoundFloat.maximal_interesting</samp>&rsquo;
    </li></ul>

</dd>
</dl>

<hr>
<a name="Invariant-filters"></a>
<div class="header">
<p>
Previous: <a href="#Invariant-list" accesskey="p" rel="previous">Invariant list</a>, Up: <a href="#Daikon-output" accesskey="u" rel="up">Daikon output</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Invariant-filters-1"></a>
<h3 class="section">5.6 Invariant filters</h3>

<a name="index-invariant-filters"></a>
<a name="index-filters"></a>

<p>Invariant filters are used to suppress the printing of invariants that
are true, but not considered &ldquo;interesting&rdquo; &mdash; usually
because the invariants are considered obvious or redundant in a given
context.
</p>
<p>The following is a list of the invariant filters that Daikon supports.
Each of these filters has a corresponding configuration enable switch;
by default, all filters are enabled.  See <a href="Enhancing-Daikon-output.html#Options-to-enable_002fdisable-filters">Options to enable/disable filters</a>,
for details.
</p>
<ul>
<li> <a name="index-DerivedParameterFilter"></a>
DerivedParameterFilter: suppress parameter-derived postcondition invariants

<p>This filter suppresses invariants at procedure exit points that are
uninteresting because they refer to &lsquo;<samp>pre-state</samp>&rsquo; variables derived from
pass-by-value parameters.  For example, suppose that <code>param</code> is a
parameter to a
Java method.  If <code>param</code> itself is modified, that change won&rsquo;t be
visible to a caller, so it&rsquo;s uninteresting to print.  If <code>param</code> points
to an object, and that object is changed, that is visible, but
only if <code>param</code> hasn&rsquo;t changed; otherwise, the invariant would report a
change in some object other than the one that was passed in.
</p>

</li><li> <a name="index-ObviousFilter"></a>
<a name="index-implied-invariant"></a>
<a name="index-redundant-invariant"></a>
ObviousFilter: suppress &ldquo;obvious&rdquo;, or redundant, invariants &mdash;
that is, invariants that are implied by some other invariant

<p>This filter suppresses any invariant that is a logical consequence of
other invariants that are printed.  This keeps the output from becoming
cluttered with redundant facts.  Some examples are:
</p>
<ul>
<li> If &lsquo;<samp>size(args[])==0</samp>&rsquo; is shown, then &lsquo;<samp>size(args[])-1==-1</samp>&rsquo; is
obvious and will not be displayed by default.
</li><li> If &lsquo;<samp>this.topOfStack &lt; size(this.theArray[])-1</samp>&rsquo; is shown, then
&lsquo;<samp>this.topOfStack &lt; size(this.theArray[])</samp>&rsquo; is obvious and will not be
displayed by default.

</li></ul>

<p>To suppress even more invariants, use the <samp>--suppress_redundant</samp>
command-line option; see <a href="Running-Daikon.html#Options-to-control-invariant-detection">Options to control invariant detection</a>.
</p>

</li><li> <a name="index-OnlyConstantVariablesFilter"></a>
OnlyConstantVariablesFilter: suppress invariants containing only constants

<p>This filter suppresses comparison invariants in which all of the
variables being compared were observed to be constant.  In the current
version of Daikon, most such invariants are not even created in the
first place, because constants are detected on an early pass over the
data.  However, Daikon will note that all of the invariants that had
any particular constant value were also equal to each other: such
invariants will be suppressed by this filter.
</p>

</li><li> <a name="index-ParentFilter"></a>
ParentFilter:  filter invariants that match a parent program point invariant

<p>A controlled invariant is an invariant that is &ldquo;controlled&rdquo; &mdash; or
implied &mdash; by a parent program point in the dataflow hierarchy.
For example, for Java instrumented
code each class is associated with an object program point, which
contain invariants that are found at the entry and exit of all public
methods.  So in addition to the usual program points such as
<code>StackAr.StackAr(int):::ENTER</code> and
<code>StackAr.isEmpty():::EXIT48</code>, Daikon outputs invariants for the
artificial program point <code>StackAr:::OBJECT</code>.  The invariants for
<code>StackAr:::OBJECT</code> control the invariants for
<code>StackAr.StackAr(int):::ENTER</code> and
<code>StackAr.isEmpty():::EXIT48</code>, because the former imply the latter.
Because of this redundancy, controlled invariants are not displayed by
default.  Note that if for some reason, the controlling invariant is not
displayed (for example, because it&rsquo;s unjustified), then the controlled
invariant <em>will</em> be displayed.
</p>
</li><li> <a name="index-SimplifyFilter"></a>
SimplifyFilter:  eliminate redundant invariants using Simplify

<p>Daikon contains built-in test that remove most redundant (logically
implied) invariants from its output; see
</p>
<p>Daikon can use the Simplify theorem-prover to eliminate even more
implied invariants than Daikon&rsquo;s built-in tests are able to eliminate.
Simplify must be installed in
order to take advantage of this filter (see <a href="Troubleshooting.html#Installing-Simplify">Installing Simplify</a>).
</p>
<p>If you don&rsquo;t also specify the <samp>--suppress_redundant</samp> command-line
option (see <a href="Running-Daikon.html#Options-to-control-invariant-detection">Options to control invariant detection</a>) to enable
Simplify processing, this filter doesn&rsquo;t do anything.
</p>
</li><li> <a name="index-UnjustifiedFilter"></a>
UnjustifiedFilter:  suppress unjustified invariants

<p>For every invariant, Daikon estimates the probability of that invariant
happening by chance.  If that probability is less than the limit, then
the invariant is deemed to be an actual invariant, not just a chance
occurrence.  Currently the limit is .01.  So by default, only invariants
with probabilities of less than 1% are shown.  See the <samp>--conf_limit</samp>
option (<a href="Running-Daikon.html#Options-to-control-invariant-detection">Options to control invariant detection</a>).
</p>

</li><li> <a name="index-UnmodifiedVariableEqualityFilter"></a>
UnmodifiedVariableEqualityFilter:  suppress invariants that merely indicate that a variable was unmodified

<p>This filter is only useful for <samp>ESC</samp> output.
</p>
</li></ul>


<hr>
<div class="header">
<p>
Previous: <a href="#Invariant-list" accesskey="p" rel="previous">Invariant list</a>, Up: <a href="#Daikon-output" accesskey="u" rel="up">Daikon output</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html#General-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
